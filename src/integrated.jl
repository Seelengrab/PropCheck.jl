using Random: Random, shuffle
using RequiredInterfaces

"""
    AbstractIntegrated{T}

Abstract supertype for all integrated shrinkers.
The `T` type parameter describes the kinds of objects generated by this integrated shrinker.
This is usually going to be a [`Tree`](@ref) of objects.

Required methods:

  * `generate(rng::AbstractRNG, ::A) where A <: AbstractIntegrated`
  * `freeze(::A) where A <: AbstractIntegrated`

Fallback definitions:

  * `Base.IteratorEltype -> Base.HasEltype()`
  * `Base.IteratorSize -> Base.SizeUnknown()`
  * `Base.eltype -> T`
  * `Base.iterate(::AbstractIntegrated, rng=default_rng())`
    * Requires `generate`
"""
abstract type AbstractIntegrated{T} end
@required AbstractIntegrated begin
    generate(::AbstractRNG, ::AbstractIntegrated)
    freeze(::AbstractIntegrated)
end

"""
    freeze(::T) where T <: AbstractIntegrated -> T

"Freezes" an `AbstractIntegrated` by returning a new object that has a `generate` method,
and can be wrapped in a new integrated shrinker.
"""
freeze(::AbstractIntegrated)

function Base.iterate(g::AbstractIntegrated, rng=default_rng())
    el = generate(rng, g)
    el === nothing && return nothing
    (el, rng)
end
Base.IteratorEltype(::Type{<:AbstractIntegrated}) = Base.HasEltype()
Base.IteratorSize(::Type{<:AbstractIntegrated}) = Base.SizeUnknown()
Base.eltype(::Type{<:AbstractIntegrated{T}}) where T = T

#######
# Unassuming Integrated
#######

"""
    InfiniteIntegrated{T} <: AbstractIntegrated{T}

Abstract supertype for all integrated shrinkers that provide infinite generation of elements.

Fallback definitions:
    * `Base.IteratorSize(::Type{<:InfiniteIntegrated}) = Base.IsInfinite()`

Overwriting `Base.IteratorSize` for subtypes of this type is disallowed.
"""
abstract type InfiniteIntegrated{T} <: AbstractIntegrated{T} end
Base.IteratorSize(::Type{<:InfiniteIntegrated}) = Base.IsInfinite()

"""
    Integrated{T} <: InfiniteIntegrated{T}

A naive integrated shrinker, only providing extremely basic functionality for
generating and shrinking [`Tree`](@ref)s. Default fallback if no other, more
specialized type exists.

!!! warning "Pending Redesign"
    This type is likely going to be redesigned in the future. Methods constructing it
    are not stable, and may be removed at any point.
"""
struct Integrated{T,F} <: InfiniteIntegrated{T}
    gen::F
end
function Integrated(m::Manual{T}, s=m.shrink) where {T}
    g = m.gen
    gen(rng) = unfold(Shuffle ∘ s, generate(rng, g))
    treeType = integratorType(T)
    Integrated{treeType,typeof(gen)}(gen)
end
function Integrated(m::Generator{T,F}, s=shrink) where {T,F}
    gen(rng) = unfold(Shuffle ∘ s, generate(rng, m))
    treeType = integratorType(T)
    Integrated{treeType,typeof(gen)}(gen)
end
function Integrated(el::Tree{T}) where T
    gen = Returns(el)
    treeType = integratorType(T)
    Integrated{treeType,typeof(gen)}(gen)
end

function integratorType(u::Union)
    types = getSubtypes(u)
    Union{(Tree{T} for T in types)...}
end
integratorType(::Type{T}) where T = Tree{T}

generate(rng::AbstractRNG, i::Integrated{T}) where T = i.gen(rng)

"""
    ExtentIntegrated{T} <: InfiniteIntegrated{T}

An integrated shrinker which has bounds. The bounds can be accessed with the `extent` function
and are assumed to have `first` and `last` method defined for them.

Required methods:

  * `extent(::ExtentIntegrated)`
"""
abstract type ExtentIntegrated{T} <: InfiniteIntegrated{T} end
@required ExtentIntegrated extent(::ExtentIntegrated)

"""
    IntegratedRange{T,R,G,F} <: ExtentIntegrated{T}

An integrated shrinker describing a range of values.

The values created by this shrinker shrink according to the given shrinking function.
The shrinking function must ensure that the produced values are always contained within the bounds
of the given range.
"""
struct IntegratedRange{T,R,G,F} <: ExtentIntegrated{T}
    bounds::R
    gen::G
    function IntegratedRange(bounds::R, gen, shrink::F) where {R <: AbstractRange,F}
        igen = Integrated(gen, shrink)
        new{Tree{eltype(R)}, R, typeof(igen), F}(bounds, igen)
    end
end
generate(rng::AbstractRNG, i::IntegratedRange) = generate(rng, i.gen)
extent(ir::IntegratedRange) = (first(ir.bounds), last(ir.bounds))

"""
    IntegratedConst{T,R,G} <: ExtentIntegrated{T}

An integrated shrinker describing a constant. The shrinker will always produce that value, which
doesn't shrink.
"""
struct IntegratedConst{T,R,G} <: ExtentIntegrated{T}
    bounds::R
    gen::G
    function IntegratedConst(c::T) where T
        gen = Integrated(Tree(c))
        new{Tree{T}, T, typeof(gen)}(c, gen)
    end
end
generate(rng::AbstractRNG, i::IntegratedConst) = generate(rng, i.gen)
extent(ir::IntegratedConst) = (ir.bounds, ir.bounds)

"""
    IntegratedUnique(vec::Vector{ElT}, shrink::S) where {ElT,S}
    IntegratedUnique{T,ElT,S} <: InfiniteIntegrated{T}

An integrated shrinker, taking a vector `vec`. The shrinker will produce all unique values of `vec`
in a random order before producing a value it returned before. The values produced by this shrinker
shrink according to `shrink`.
"""
mutable struct IntegratedUnique{T,ElT,S} <: InfiniteIntegrated{T}
    els::Vector{ElT}
    cache::Vector{ElT}
    @constfield shrink::S

    function IntegratedUnique(vec::Vector{T}, shrink::S) where {T,S}
        treeType = integratorType(T)
        els = shuffle(vec)
        cache = sizehint!(similar(els, 0), length(els))
        new{treeType,T,S}(els, cache, shrink)
    end
end

function generate(rng::AbstractRNG, i::IntegratedUnique)
    el = popfirst!(i.els)
    push!(i.cache, el)
    if isempty(i.els)
        # swap, so we're not wasteful with memory
        i.els, i.cache = i.cache, i.els
        shuffle!(rng, i.els)
    end
    unfold(Shuffle ∘ i.shrink, el)
end

freeze(i::IntegratedUnique{T}) where {T} = Generator{T}(rng -> generate(rng, i))

"""
    IntegratedVal(val::V, shrink::S) where {V,S}
    IntegratedVal{T,V,S} <: InfiniteIntegrated{T}

An integrated shrinker, taking a value `val`. The shrinker will always produce `val`, which
shrinks according to `shrink`.

If `V <: Number`, shrinking functions given to this must produce values in

 * `[typemin(V), v]` if `v > zero(V)`
 * `[v, typemax(V)]` if `v < zero(V)`
 * no values if `iszero(v)`

This shrinker supports `extent` out of the box if `V <: Number`. For other types, you need
to define `extent(::IntegratedVal{Tree{T}})`
"""
struct IntegratedVal{T,V,S} <: ExtentIntegrated{T}
    val::V
    shrink::S
    function IntegratedVal(v::V, s::S) where {V,S}
        new{Tree{V},V,S}(v, s)
    end
end

generate(_::AbstractRNG, iv::IntegratedVal) = unfold(Shuffle ∘ iv.shrink, iv.val)
freeze(i::IntegratedVal) = i
function extent(iv::IntegratedVal{Tree{T}}) where T<:Number
    iszero(iv.val) && return (zero(T), zero(T))
    if iv.val < zero(T)
        return (iv.val, typemax(T))
    else
        return (typemin(T), iv.val)
    end
end

"""
    FiniteIntegrated{T} <: AbstractIntegrated{Union{Tree{T}, Nothing}}

An integrated shrinker producing only a finite number of elements.

 * `Base.IteratorSize(::FiniteIntegrated)` must return a `Base.HasLength()` or `Base.HasShape`.
   * `length(::T)` needs to be implemented for your `T <: FiniteIntegrated`; there is no fallback.
   * If your `T <: FiniteIntegrated` has a shape, return that from `IteratorSize` instead & implement `size` as well.

Once the integrated generator is exhausted, `generate(::FiniteIntegrated)` will return `nothing`.
"""
abstract type FiniteIntegrated{T} <: AbstractIntegrated{T} end
Base.IteratorSize(::Type{<:FiniteIntegrated}) = Base.HasLength()
freeze(fi::FiniteIntegrated) = fi

"""
    IntegratedOnce(el[, shrink=shrink])
    IntegratedOnce{T} <: FiniteIntegrated{Tree{T}}

An integrated shrinker that produces a shrink tree with the value `el` at its root exactly once.
Afterwards, the integrated shrinker produces `nothing`.
"""
mutable struct IntegratedOnce{T, S} <: FiniteIntegrated{Tree{T}}
    @constfield el::T
    @constfield shrink::S
    done::Bool
    function IntegratedOnce(el::T, shrink::S=shrink) where {T,S}
        new{T, S}(el, shrink, false)
    end
end
Base.length(::IntegratedOnce) = 1

function generate(::AbstractRNG, oi::IntegratedOnce)
    oi.done && return nothing
    oi.done = true
    unfold(Shuffle ∘ oi.shrink, oi.el)
end

"""
    IntegratedFiniteIterator(itr[, shrink=shrink])
    IntegratedFiniteIterator{T} <: FiniteIntegrated{T}

An integrated shrinker taking arbitrary iterables that have a length or a shape. Once the iterator is
exhausted, the integrated shrinker produces `nothing`.

The values produced by this integrated shrinker shrink according to the given shrinking function.
"""
mutable struct IntegratedFiniteIterator{T,I,S,IS} <: FiniteIntegrated{Tree{T}}
    @constfield itr::I
    @constfield shrink::S
    state::IS
    function IntegratedFiniteIterator(itr::I, shrink::S=shrink) where {I,S}
        !(Base.IteratorSize(I) isa Base.HasLength ||
            Base.IteratorSize(I) isa Base.HasShape) &&
            throw(ArgumentError("The given iterator does not have a finite length!"))
        itr isa AbstractIntegrated && throw(ArgumentError("`IntegratedFiniteIterator` cannot iterate an `$I`!"))
        state = iterate(itr)
        new{eltype(I), I, S, Union{Nothing, typeof(state)}}(itr, shrink, state)
    end
end
Base.IteratorSize(fii::IntegratedFiniteIterator) = Base.IteratorSize(fii.itr)
Base.size(fii::IntegratedFiniteIterator) = if Base.IteratorSize(fii.itr) isa Base.HasShape
    size(fii.itr)
else
    throw(ArgumentError("The iterator wrapped by this `FiniteIteratorIntegrated` does not have a shape!"))
end
Base.length(fii::IntegratedFiniteIterator) = length(fii.itr)
Base.isdone(fii::IntegratedFiniteIterator) = isnothing(fii.state)

function generate(_::AbstractRNG, fii::IntegratedFiniteIterator{T}) where T
    fii.state isa Nothing && return nothing
    el, nstate = fii.state
    fii.state = iterate(fii.itr, nstate)
    unfold(Shuffle ∘ fii.shrink, el)::Tree{T}
end

"""
    ChainIntegrated(is::AbstractIntegrated...)
    ChainIntegrated{Eltype, N, Is, Finite} where {Eltype, N,
                                            Is <: NTuple{N, <:AbstractIntegrated}, Finite} <: AbstractIntegrated{Eltype}

An integrated shrinker chaining together a number of given integrated shrinkers, producing the values
they generate one after another.

All except the last argument must have some finite length, meaning the integrated shrinker must subtype [`FiniteIntegrated`](@ref).
Only the last integrated shrinker is allowed to be only `<: InfiniteIntegrated`.

The values produced by this integrated shrinker shrink according to the shrinking function given to the shrinker that originally
produce them.

The `Finite` type parameter is a `Bool`, indicating whether this `IntegratedChain` is finite or not.
"""
mutable struct IntegratedChain{T, N, Is <: NTuple{N, AbstractIntegrated}, Finite} <: AbstractIntegrated{T}
    index::Int
    @constfield chain::Is

    function IntegratedChain(is::AbstractIntegrated...)
        start = is[begin:end-1]
        all(start) do i
            i isa FiniteIntegrated
        end || throw(ArgumentError("Only the last argument to `ChainIntegrated` is allowed to not have a length!"))
        T = Union{eltype.(is)...}
        Is = Tuple{typeof.(is)...}
        new{T, length(is), Is, last(is) isa FiniteIntegrated}(firstindex(is), is)
    end
end
Base.isdone(ci::IntegratedChain) = ci.index > lastindex(ci.chain)
freeze(ci::IntegratedChain) = deepcopy(ci)
Base.IteratorSize(ic::IntegratedChain{T, N, Is, true}) where {T,N,Is}  = Base.HasLength()
Base.IteratorSize(ic::IntegratedChain{T, N, Is, false}) where {T,N,Is} = Base.IsInfinite()
Base.length(ic::IntegratedChain{T, N, Is, true}) where {T,N,Is}        = sum(length, ic.chain)

function generate(rng::AbstractRNG, ci::IntegratedChain)
    while true
        # we exhausted all integrated shrinkers
        Base.isdone(ci) && return nothing
        integrated = ci.chain[ci.index]
        ret = generate(rng, integrated)
        if ret isa Nothing
            # the integrated shrinker was exhausted, so try the next one
            ci.index += 1
            continue
        else
            return ret
        end
    end
end

"""
    IntegratedLengthBounded(is::AI, bound::Int) where {T, AI <: AbstractIntegrated{T}}
    IntegratedLength{T, AbstractIntegrated{T}}

An integrated shrinker bounding the number of values generated by the passed integrated shrinker.
This has the ability to transform any [`AbstractIntegrated`](@ref) into a [`FiniteIntegrated`](@ref).

The given bound must be a positive value. If a `fi::FiniteIntegrated` is given as the integrated shrinker,
the bound is chosen to be `min(length(fi), bound)`.

The values produced by this integrated shrinker shrink according to the shrinking function given to the original
integrated shrinker wrapped by `IntegratedLengthBounded`.
"""
mutable struct IntegratedLengthBounded{T, I} <: FiniteIntegrated{T}
    curcount::Int
    @constfield bound::Int
    @constfield integrated::I
    function IntegratedLengthBounded(int::AbstractIntegrated{T}, bound::Int) where T
        bound < 0 && throw(ArgumentError("Given bound must be a positive number!"))
        new{T, typeof(int)}(1, bound, int)
    end
    function IntegratedLengthBounded(int::FiniteIntegrated{T}, bound::Int) where T
        bound = min(bound, length(int))
        bound < 0 && throw(ArgumentError("Given bound must be a positive number!"))
        new{T, typeof(int)}(1, bound, int)
    end
end
Base.length(ilb::IntegratedLengthBounded) = ilb.bound
Base.isdone(ilb::IntegratedLengthBounded) = ilb.curcount > ilb.bound

function generate(rng::AbstractRNG, ilb::IntegratedLengthBounded)
    Base.isdone(ilb) && return nothing
    ilb.curcount += 1
    generate(rng, ilb)
end

################################################
# utility for working with integrated generators
################################################

freeze(i::InfiniteIntegrated{T}) where {T} = Generator{T}(i.gen)
dontShrink(i::AbstractIntegrated{T}) where {T} = Generator{T}(rng -> root(generate(rng, i)))
dependent(g::Generator{T,F}) where {T,F} = Integrated{T,F}(g.gen)

"""
    map(f, i::AbstractIntegrated) -> AbstractIntegrated

Maps `f` lazily over all elements in `i`, producing an `AbstractIntegrated` generating the mapped values.
"""
function PropCheck.map(f::F, gen::AbstractIntegrated{T}) where {T, F}
    rettypes = reduce(hcat, (Base.return_types(f, (t,)) for t in unpackTreeUnion(T)))
    mapType = integratorType(Union{rettypes...})
    function genF(rng)
        val = generate(rng, freeze(gen))
        val === nothing && return val
        map(f, val)
    end
    dependent(Generator{mapType}(genF))
end

unpackTreeUnion(::Type{Tree{T}}) where T = (T,)
function unpackTreeUnion(T::Type)
    !(T isa Union) && return (T,)
    (unpackTreeUnion(T.a)..., unpackTreeUnion(T.b)...)
end

# we are Applicative with this
function PropCheck.map(funcs::AbstractIntegrated{Tree{F}}, gen::AbstractIntegrated{Tree{T}}) where {T,F}
    genF(rng) = interleave(generate(rng, funcs), generate(rng, gen))
    rootF = root(generate(funcs))
    retT = reduce(typejoin, Base.return_types(rootF, (T,)))
    Integrated{Tree{retT}, typeof(genF)}(genF)
end

"""
    filter(p, i::AbstractIntegrated[, trim=false]) -> AbstractIntegrated

Filters `i` lazily such that all elements contained fulfill the predicate `p`, i.e. all elements for which `p` is `false` are removed.

`trim` controls whether subtrees are removed completely when the root doesn't
fulfill the predicate or whether only that root should be skipped, still trying to
shrink its subtrees. This trades performance (less shrinks to check) for quality
(fewer/less diverse shrink values tried).
"""
function Base.filter(p, genA::AbstractIntegrated{T}, trim=false) where {T}
    function genF(rng)
        while true
            val = generate(rng, freeze(genA))
            val === nothing && return nothing
            local element = iterate(filter(p, val, trim))
            element !== nothing && return first(element)
        end
    end
    gen = Generator{T}(genF)
    dependent(gen)
end

######################
# Creating specific `Integrated`
#####################

function listAux(genLen::ExtentIntegrated{W}, genA::AbstractIntegrated{T}) where {W, T}
    n = dontShrink(genLen)
    function genF(rng)
        f = freeze(genA)
        [ generate(rng, f) for _ in 1:generate(rng, n) ]
    end
    Generator{Vector{Tree{T}}}(genF)
end

function vector(@nospecialize(genLen::ExtentIntegrated), genA::AbstractIntegrated{T}) where {T}
    function genF(rng)
        while true
            treeVec = generate(rng, listAux(genLen, genA))
            # TODO: this filtering step is super ugly. It would be better to guarantee not to
            # generate incorrect lengths in the first place.
            intr = interleave(treeVec)
            flat = filter(intr, true) do v
                length(v) >= first(extent(genLen))
            end
            ret = iterate(flat)
            ret !== nothing && return first(ret)::Tree{Vector{eltype(T)}}
        end
    end
    gen = Generator{Tree{Vector{eltype(T)}}}(genF)
    dependent(gen)
end

function arrayAux(genLen::AbstractIntegrated, genA::Integrated{T}) where {T}
    n = dontShrink(genLen)
    function genF(rng)
        arrsize = generate(rng, n)
        frozen = freeze(genA)
        arr = Array{T}(undef, arrsize...)
        for idx in eachindex(arr)
            arr[idx] = generate(rng, frozen)
        end
        arr
    end
    Generator{Array{Tree{T}, N} where N}(genF)
end

array(genSize::AbstractIntegrated{Tree{T}}, genA) where T <: Integer = array(PropCheck.tuple(iconst(0x1), genSize), genA)
function array(genSize::AbstractIntegrated{Tree{TP}}, genA::AbstractIntegrated{T}) where {T, TP <: NTuple}
    function genF(rng)
        treeArr = generate(rng, arrayAux(genSize, genA))
        interleave(treeArr)
    end
    # what a horrible hack
    gen = Generator{Tree{Array{eltype(T), length(TP.parameters)}}}(genF)
    dependent(gen)
end

function tupleAux(genLen::AbstractIntegrated, genA::AbstractIntegrated{T}) where {T}
    n = dontShrink(genLen)
    genF(rng) = ntuple(_ -> generate(rng, freeze(genA)), generate(rng, n))
    Generator{NTuple{N, Tree{T}} where N}(genF)
end

"""
    tuple(genLen::AbstractIntegrated, genA::AbstractIntegrated)

Generates a tuple of a generated length, using the elements produced by `genA`.
"""
function tuple(genLen::AbstractIntegrated, genA::AbstractIntegrated{T}) where {T}
    genF(rng) = interleave(generate(rng, tupleAux(genLen, genA)))
    gen = Generator{Tree{NTuple{N, eltype(T)} where N}}(genF)
    dependent(gen)
end

"""
    str(len::ExtentIntegrated[, alphabet::AbstractIntegrated])

Generates a string using the given `genLen` as a generator for the length.
The default alphabet is `typemin(Char):"\xf7\xbf\xbf\xbf"[1]`, which is all
representable `Char` values. 
"""
function str(genLen::ExtentIntegrated, alphabet::AbstractIntegrated=isample(typemin(Char):"\xf7\xbf\xbf\xbf"[1]))
    map(join, vector(genLen, alphabet))
end

function interleave(intr::AbstractIntegrated...)
    rettuple = Tree{Tuple{eltype.(eltype.(intr))...}}
    gen(rng) = interleave(generate.(rng, intr))
    Integrated{rettuple, typeof(gen)}(gen)
end