var documenterSearchIndex = {"docs":
[{"location":"Examples/chaining.html#Chaining-generation","page":"Generator Chaining","title":"Chaining generation","text":"","category":"section"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"Sometimes, it is useful to be able to generate a finite set of \"special values\", before throwing the full brunt of possible values of a type at your function. At other times, you may want to test a few special distributions of values whose generation isn't finite, before having PropCheck.jl try a generic type-based fuzzing approach. In these cases, it's helpful to try one of the subtypes of PropCheck.FiniteIntegrated.","category":"page"},{"location":"Examples/chaining.html#IntegratedOnce","page":"Generator Chaining","title":"IntegratedOnce","text":"","category":"section"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"PropCheck.IntegratedOnce is the \"Give me a value, but please only one value\" version of PropCheck.ival. It is semantically the same as  PropCheck.IntegratedLengthBounded(ival(x), 1) (which we'll look at in detail later), but with a more efficient implementation.","category":"page"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"Here's an example:","category":"page"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"using PropCheck\nusing PropCheck: IntegratedOnce\n\ngen = IntegratedOnce(5)\ntree = generate(gen)\n\nsubtrees(tree) |> collect # The shrink tree is unfolded as usual\ngenerate(gen) isa Nothing # but subsequent `generate` calls don't produce any value\ngenerate(gen) isa Nothing","category":"page"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"If you know that you're only going to require the value to be tested exactly once, while still being able to test its shrinks in case the property fails, IntegratedOnce can be a very good choice. An example use case is for regression testing of known previous failures.","category":"page"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"Of course, this kind of integrated shrinker can be mapped and filtered just the same as regular infinite generators:","category":"page"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"gen = filter(iseven, IntegratedOnce(5));\ntree = generate(gen)\nroot(tree)\nsubtrees(tree) |> collect\ngen = map(x -> 2x, IntegratedOnce(5));\ntree = generate(gen)\nroot(tree)\nsubtrees(tree) |> collect","category":"page"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"warning: Copying & exhaustion\nKeep in mind that all finite generators can only be exhausted once. So be sure to deepcopy the finite generators if you want to reuse them in multiple places. This may later be relaxed to only copy for some finite generators, in order to reuse as many reusable generators as possible.","category":"page"},{"location":"Examples/chaining.html#IntegratedFiniteIterator","page":"Generator Chaining","title":"IntegratedFiniteIterator","text":"","category":"section"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"PropCheck.IntegratedFiniteIterator can be used to produce the values of a given finite iterator, one after the other, before suspending generation of new values.","category":"page"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"This is useful when you have a known set of special values that you want to try, which are likely to lead to issues. IntegratedOnce is similar to this integrated shrinker, with the difference being that IntegratedFiniteIterator can take any arbitrary iterable (except other AbstractIntegrated) to produce their values in exactly the order they were originally produced in from the iterator.","category":"page"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"using PropCheck\nusing PropCheck: IntegratedFiniteIterator\n\niter = 1:2:21\ngen = IntegratedFiniteIterator(iter); # all odd values between 1 and 21, inclusive\nlength(gen) == length(iter)\nall(zip(gen, iter)) do (gval, ival)\n    root(gval) == ival\nend\ngenerate(gen) isa Nothing # and of course, once it's exhausted that's it","category":"page"},{"location":"Examples/chaining.html#IntegratedLengthBounded","page":"Generator Chaining","title":"IntegratedLengthBounded","text":"","category":"section"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"PropCheck.IntegratedLengthBounded can be used to limit an PropCheck.AbstractIntegrated to a an upperbound in the count of generated values, before generation is suspended.","category":"page"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"This can be useful for only wanting to generate a finite number of elements from some other infinite generator before switching to another one, as mentioned earlier. The basic usage is passing an AbstractIntegrated as well as the desired maximum length. If a FiniteIntegrated is passed, the resulting integrated shrinker has as its length the min of the given FiniteIntegrated and the given upper bound.","category":"page"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"using PropCheck\nusing PropCheck: IntegratedLengthBounded, IntegratedOnce\n\ngen = IntegratedLengthBounded(itype(Int8), 7);\ncollect(gen) # 7 `Tree{Int8}`\n\ngen = IntegratedLengthBounded(IntegratedOnce(42), 99);\nlength(gen) # still only one `Tree{Int}`\ncollect(gen)","category":"page"},{"location":"Examples/chaining.html#IntegratedChain","page":"Generator Chaining","title":"IntegratedChain","text":"","category":"section"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"While itself not guaranteed to be finite, PropCheck.IntegratedChain is the most useful tool when combining finite generators in this fashion. Its constructor takes any number of AbstractIntegrated, though all but the last one are required to subtype FiniteIntegrated. The last integrated shrinker may be truly AbstractIntegrated, though being FiniteIntegrated is also ok.","category":"page"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"This allows IntegratedChain to be a building block for grouping special values together, or for preparing a known set of previous failures into a regression test, while still allowing the values to shrink according to the shrinking function used during the original generation, if available.","category":"page"},{"location":"Examples/chaining.html","page":"Generator Chaining","title":"Generator Chaining","text":"using PropCheck\nusing PropCheck: IntegratedChain, IntegratedOnce, IntegratedFiniteIterator\nusing Test\n\nfunction myAdd(a::Float64, b::Float64)\n    # whoops, this isn't `add` at all!\n    1.0 <= a && return NaN\n    a + b\nend\n\npreviousFailure = interleave(IntegratedOnce(0.5), IntegratedOnce(0.2));\nspecialCases = IntegratedFiniteIterator((NaN, -1.0, 1.0, 0.0));\nspecialInput = interleave(specialCases, deepcopy(specialCases)); # take care to not consume too early\n\naddGen = IntegratedChain(previousFailure, # fail early if this doesn't work\n                         specialInput, # some known special cases\n                         PropCheck.tuple(ival(2), itype(Float64))); # finally, fuzzing on arbitrary stuff!\n\nfunction nanProp(a, b)\n    res = myAdd(a,b)\n    # only `NaN` should produce `NaN`\n    (isnan(a) || isnan(b)) == isnan(res)\nend\n\n@testset \"myAdd\" begin # We find a failure past our first chain of special cases\n    @test check(splat(nanProp), addGen)\nend","category":"page"},{"location":"Examples/properties.html#Composing-Generators","page":"Composing Generators","title":"Composing Generators","text":"","category":"section"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"I've mentioned in the last section how we need tuple and vector to generate tuples and vectors of values respectively. In this chapter, we'll use these to build a slightly more complex example.","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"Let's take a look at a more complicated object and an associated function, like this one for example:","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"using PropCheck # hide\n\nstruct Student\n   name::String\n   age::Int\n   grades::Dict{String,Int} # subject => points\nend\n\n\"\"\"\n    passes(s::Student)\n\nChecks whether a student passes this grade. At most one subject may have a failing grade with less than 51 points.\n\"\"\"\nfunction passes(s::Student)\n    count(<(51), values(s.grades)) <= 1\nend","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"First, we're going to need a custom generator for our grades:","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"grade = map(Base.splat(Pair), PropCheck.interleave(itype(String), isample(0:100))) # random subject, with points in 0:100\ngradegen = map(Base.splat(Dict{String,Int}), PropCheck.tuple(isample(1:10), grade))","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"info: Different ranges\nisample(2:10, PropCheck.shrinkTowards(2)) gives us an integrated shrinker producing elements in the range 2:10. They'll shrink towards 2.","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"Now to our student:","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"students = map(Base.splat(Student), PropCheck.interleave(itype(String), itype(Int), gradegen))\ncheck(passes, students)","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"And we can see that just generic shrinking produced the minimal student that doesn't pass. A nameless, ageless student who received no points on two subjects. Note that due to us using a dictionary (which forces unique keys), the two subjects have different names!","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"PropCheck tries to be fast when it can, so this reduction barely took any time:","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"pairs(@timed @time check(passes, students))","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"Let's say now that we expect our students to be between 10-18 years old, have a name consisting of 5-20 lowercase ASCII letters and having between 5 and 10 subjects of 5-15 lowercase ASCII letters. We could build them like this:","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"subj_name = PropCheck.str(isample(5:15), isample('a':'z'))\ngrade = map(Base.splat(Pair), PropCheck.interleave(subj_name, isample(0:100))) # random subject, with points in 0:100\ngradegen = map(Base.splat(Dict{String,Int}), PropCheck.vector(isample(5:10), grade))\nstud_name = PropCheck.str(isample(5:20), isample('a':'z')) # we don't want names shorter than 5 characters\nstud_age = isample(10:18) # our youngest student can only be 10 years old\nstudents = map(Base.splat(Student), PropCheck.interleave(stud_name, stud_age, gradegen))\ncollect(Iterators.take(students, 5))","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"which will preserve the invariants described during generation when shrinking:","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"check(passes, students)","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"The student returned has a name with 5 characters, is 10 years old, has taken two distinct subjects and received 0 points in both of them. We can do much better if we modify our generators a bit, at the cost of having a smaller pool of possible tests:","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"# sample their classes\nsubj_name = isample([\"Geography\", \"Mathematics\", \"English\", \"Arts & Crafts\", \"Music\", \"Science\"], PropCheck.noshrink)\n\n# random subject, with points in 0:100\ngrade = map(Base.splat(Pair), PropCheck.interleave(subj_name, isample(0:100)))\n\n# generate their grades\ngradegen = map(Base.splat(Dict{String,Int}), PropCheck.vector(isample(5:10), grade))\n\n# give them a name that doesn't vanish\nstud_name = isample([\"Alice\", \"Bob\", \"Claire\", \"Devon\"], PropCheck.noshrink)\n\n# our youngest student can only be 10 years old\nstud_age = isample(10:18)\n\n# create our students\nstudents = map(Base.splat(Student), PropCheck.interleave(stud_name, stud_age, gradegen))\n\n# and check that not all students pass\nusing Test\ntry # hide\n@testset \"All students pass\" begin\n    @test check(passes, students)\nend\ncatch # hide\nend # hide","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"note: Dictionaries\nWhile this example directly splats a vector into the Dict{String,Int} constructor, this is in general not optimal. Dict will delete previously set values if a key is duplicated, so it's usually better to generate a list of unique keys first, which is then combined with a seperately generated list of values. In order to generate that list of unique keys, you can use iunique.","category":"page"},{"location":"Examples/properties.html","page":"Composing Generators","title":"Composing Generators","text":"note: Test stdlib and `@test`\nCurrently, check returns the minimized failing testcase, so that @test displays that the test has evaluated to a non-Boolean. This is suboptimal and misuses the @test macro. In the future, this may be replaced by a @check macro, which creates a custom TestSet for recording what kind of failure was experienced.","category":"page"},{"location":"Examples/basic.html#Basic-Usage","page":"Basic Usage","title":"Basic Usage","text":"","category":"section"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"Property based testing is all about having a function to test and a set of properties that should hold on the outputs of that function, given its inputs. It is, in part, a philosophy of test driven design.","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"Consider this add function:","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"function add(a,b)\n    a + b\nend","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"How would we test this? First we have to define the properties we expect to hold. In this case, it's just the laws of addition:","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"commutative(a,b)   =  add(a,b) == add(b,a)\nassociative(a,b,c) =  add(add(a,b), c) == add(a, add(b,c))\nidentity_add(a)    =  add(a,zero(a)) == a\nfunction successor(a::T, b::T) where T\n    a, b = minmax(a,b)\n    sumres = a\n    for _ in one(b):b\n        sumres = add(sumres, one(b))\n    end\n\n    sumres == add(a,b)\nend","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"To check that the properties hold, we first need to define a generator for our input. In this case, we are interested in integers, so let's define a simple generator that just draws some random numbers. The most basic generator PropCheck provides is itype, which generates values of a given type:","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"using PropCheck\n\ngen = PropCheck.itype(Int)","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"which we can then use to check that our identity_add property holds:","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"julia> check(identity_add, gen)\ntrue","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"Perhaps unsurprisingly (we're only forwarding to + after all), the property holds - PropCheck was unable to find a counterexample.","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"Here's an example for a property that doesn't hold, showing how PropCheck handles generated cases that fail:","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"julia> failprop(x) = add(x, one(x)) < x;\n\njulia> check(failprop, gen)\n┌ Info: Found counterexample for 'failprop', beginning shrinking...\n└   Counterexample = 909071986488726633\n[ Info: 10 counterexamples found for failprop\n0","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"PropCheck, once it finds a counterexample to our property (i.e., an input to the property that makes the property error or return false), tries to shrink the counterexample to a smaller one, pinpointing the failure to one that is more manageable when debugging. In this case, the integrated shrinker itype(Int) tries to minimize the absolute value of the generated number that still fails the property, which is 0 - 0+1 is, after all, not smaller than 0.","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"note: Overflow\nThere is a subtle bug here - if x+1 overflows when x == typemax(Int), the resulting comparison is true: typemin(Int) < typemax(Int) after all. It's important to keep these kinds of subtleties, as well as the invariants the datatype guarantees, in mind when choosing a generator and writing properties to check the datatype and its functions for.","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"We've still got three more properties to test, taking two or three arguments each, but itype only ever generates one value. Since we know the number of arguments to each function, we can pair a integrated shrinker for the appropriate arguments with splatting those arguments into the property with Base.splat to test them:","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"using Test\nadd(a,b) = a+b # hide\ncommutative(a,b)   =  add(a,b) == add(b,a) # hide\nassociative(a,b,c) =  add(add(a,b), c) == add(a, add(b,c)) # hide\nidentity_add(a)    =  add(a,zero(a)) == a # hide\nfunction successor(a::T, b::T) where T # hide\n    a, b = minmax(a,b) # hide\n    sumres = a # hide\n    for _ in one(b):b # hide\n        sumres = add(sumres, one(b)) # hide\n    end # hide\n # hide\n    sumres == add(a,b) # hide\nend # hide\nusing PropCheck # hide\ntry # hide\n@testset \"Addition\" begin\n    @test check(identity_add,       itype(UInt))\n    @test check(splat(commutative), itype(Tuple{UInt, UInt}))\n    @test check(splat(successor),   itype(Tuple{UInt, UInt}))\n    @test check(splat(associative), itype(Tuple{UInt, UInt, UInt}))\nend\ncatch # hide\nend # hide\nnothing # hide","category":"page"},{"location":"Examples/basic.html","page":"Basic Usage","title":"Basic Usage","text":"Be aware that while all checks pass, we do not have a guarantee that our code is correct for all cases. Sampling elements to test is a statistical process and as such we can only gain confidence that our code is correct. You may view this in the light of Bayesian statistics, where we update our prior that the code is correct as we run our testsuite more often. This is also true were we not using property based testing or PropCheck at all - with traditional testing approaches, only the values we've actually run the code with can be said to be tested.","category":"page"},{"location":"interfaces.html#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"PropCheck.jl provides a number of interfaces to hook into with your code. Some of these are more robust than others, while some are likely to change in the future. Nevertheless, they are documented here in order to facilitate experimentation, as well as gathering feedback on how well they work and where they have missing functionality/aren't clear enough, before an eventual 1.0 version release.","category":"page"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"The interfaces mentioned on this page are intended for user-extension, in the manner described. Overloading the functions in a different way or assuming more of an interface than is guaranteed is not supported.","category":"page"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"For the abstract-type based interfaces AbstractIntegrated and ExtentIntegrated, you can use the API provided by RequiredInterfaces.jl to check for compliance, if you want to provide a custom integrated shrinker.","category":"page"},{"location":"interfaces.html#AbstractIntegrated{T}","page":"Interfaces","title":"AbstractIntegrated{T}","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"PropCheck.AbstractIntegrated","category":"page"},{"location":"interfaces.html#PropCheck.AbstractIntegrated","page":"Interfaces","title":"PropCheck.AbstractIntegrated","text":"AbstractIntegrated{T}\n\nAbstract supertype for all integrated shrinkers. The T type parameter describes the kinds of objects generated by this integrated shrinker. This is usually going to be a Tree of objects.\n\nRequired methods:\n\ngenerate(rng::AbstractRNG, ::A) where A <: AbstractIntegrated\nfreeze(::A) where A <: AbstractIntegrated\n\nFallback definitions:\n\nBase.IteratorEltype -> Base.HasEltype()\nBase.IteratorSize -> Base.SizeUnknown()\nBase.eltype -> T\nBase.iterate(::AbstractIntegrated, rng=default_rng())\nRequires generate\n\n\n\n\n\n","category":"type"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"AbstractIntegrated is the most unassuming integrated shrinker type, requiring little more than defining generate. generate on an AbstractIntegrated is, in the current design, only going to return Trees (and others are unlikely to work/not supported by the rest of the package), but that's not technically necessary. A more sophisticated generation process than the implicit & lazy unfolding of a tree could share subtrees, which would be more like a lazy graph. While technically possible, this is not currently planned.","category":"page"},{"location":"interfaces.html#ExtentIntegrated{T}","page":"Interfaces","title":"ExtentIntegrated{T}","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"PropCheck.ExtentIntegrated","category":"page"},{"location":"interfaces.html#PropCheck.ExtentIntegrated","page":"Interfaces","title":"PropCheck.ExtentIntegrated","text":"ExtentIntegrated{T} <: InfiniteIntegrated{T}\n\nAn integrated shrinker which has bounds. The bounds can be accessed with the extent function and are assumed to have first and last method defined for them.\n\nRequired methods:\n\nextent(::ExtentIntegrated)\n\n\n\n\n\n","category":"type"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"ExtentIntegrated extends the AbstractIntegrated interface by a single method - PropCheck.extent. Its purpose is simple - values produced by an ExtentIntegrated are expected to fall within a given ordered set, with a maximum and a minimum, which is what is returned by extent.","category":"page"},{"location":"interfaces.html#InfiniteIntegrated{T}","page":"Interfaces","title":"InfiniteIntegrated{T}","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"PropCheck.InfiniteIntegrated","category":"page"},{"location":"interfaces.html#PropCheck.InfiniteIntegrated","page":"Interfaces","title":"PropCheck.InfiniteIntegrated","text":"InfiniteIntegrated{T} <: AbstractIntegrated{T}\n\nAbstract supertype for all integrated shrinkers that provide infinite generation of elements.\n\nFallback definitions:     * Base.IteratorSize(::Type{<:InfiniteIntegrated}) = Base.IsInfinite()\n\nOverwriting Base.IteratorSize for subtypes of this type is disallowed.\n\n\n\n\n\n","category":"type"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"InfiniteIntegrated are at the core of PropCheck.jl; they allow for arbitrarily long generation of new values. They are currently always implementes as stateless objects, and underpin the majority of generation that is possible with PropCheck.jl.","category":"page"},{"location":"interfaces.html#FiniteIntegrated{T}","page":"Interfaces","title":"FiniteIntegrated{T}","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"PropCheck.FiniteIntegrated","category":"page"},{"location":"interfaces.html#PropCheck.FiniteIntegrated","page":"Interfaces","title":"PropCheck.FiniteIntegrated","text":"FiniteIntegrated{T} <: AbstractIntegrated{T}\n\nAn integrated shrinker producing only a finite number of elements.\n\nBase.IteratorSize(::FiniteIntegrated) must return a Base.HasLength() or Base.HasShape.\nlength(::T) needs to be implemented for your T <: FiniteIntegrated; there is no fallback.\nIf your T <: FiniteIntegrated has a shape, return that from IteratorSize instead & implement size as well.\n\nOnce the integrated generator is exhausted, generate(::FiniteIntegrated) will return nothing.\n\n\n\n\n\n","category":"type"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"FiniteIntegrated are used for stopping generation of values. They are currently always implemented as stateful objects during generation, i.e. they cannot be restarted. This may change in the future, but is (currently) a consequence of the existing design.","category":"page"},{"location":"interfaces.html#Generation-and-Shrinking","page":"Interfaces","title":"Generation & Shrinking","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"These two functions are required if you want to customize shrinking & type-based generation. It's certainly not necessary to implement these to work with most features of this package, but they are required if you want to customize what kinds of object itype returns.","category":"page"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"PropCheck.shrink\nPropCheck.generate","category":"page"},{"location":"interfaces.html#PropCheck.shrink","page":"Interfaces","title":"PropCheck.shrink","text":"shrink(val::T) where T\n\nFunction to be used during shrinking of val. Must return an iterable of shrunk values, which can be lazy. If the returned iterable is empty, it's taken as a signal that the given value cannot shrink further.\n\nMust never return a previously input value, i.e. no value val used as input should ever be produced by shrink(val) or subsequent applications of shrink on the produced elements. This will lead to infinite looping during shrinking.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#PropCheck.generate","page":"Interfaces","title":"PropCheck.generate","text":"generate(rng::AbstractRNG, ::Type{T}) where T -> T\n\nFunction to generate a single value of type T. Falls back to constructor inspection, which will generate values for ::Any typed arguments.\n\nTypes that have rand defined for them should forward to it here, assuming rand returns the full spectrum of possible instances. Assumed to return an object of type T.\n\nnote: Float64\nA good example for when not to forward to rand is Float64 - by default, Julia only generates values in the half-open interval [0,1), meaning Inf, NaN and similar special values aren't generated at all. As you might imagine, this is not desirable for a framework that ought to find bugs in code that doesn't handle these kinds of values correctly.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#itype","page":"Interfaces","title":"itype","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"PropCheck.itype","category":"page"},{"location":"interfaces.html#PropCheck.itype","page":"Interfaces","title":"PropCheck.itype","text":"itype(T::Type[, shrink=shrink]) -> AbstractIntegrated\n\nA convenience constructor for creating integrated shrinkers, generating their values from a type.\n\nTrees created by this function will have their elements shrink according to shrink.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"In order to hook into the generation provided by itype, define generate for your type T.","category":"page"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"Generally speaking, generate should always produce the full set of possible values of a type. For example, itype(Float64) can produce every possible Float64 value, with every possible bitpattern - that includes all different kinds of NaN.","category":"page"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"Be sure to also define a shrinking function for your type, by adding a method to shrink.","category":"page"},{"location":"intro.html#Introduction","page":"Introduction to PBT","title":"Introduction","text":"","category":"section"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"What follows is a short introduction to what Property Based Testing (PBT) is from my POV. This may not be exhaustive - if you want a more formal or deeper dive into this topic, I can greatly recommend this article by one of the authors of Hypothesis, a property based testing framework. For more formal methods, check out the blog of Hillel Wayne.","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"If you're fine with the (short) introduction I'm giving, but want some sort of motivation about WHY you should care, here's a quote from him, itself referencing other people:","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"In 2010 Carmen Reinhart and Kenneth Rogoff published Growth in a Time of Debt. It’s arguably one of the most influential economics papers of the decade, convincing the IMF to push austerity measures in the European debt crisis. It was a very, very big deal.In 2013 they shared their code with another team, who quickly found a bug. Once corrected, the results disappeared.Greece took on austerity because of a software bug. That’s pretty fucked up.","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"Now that I have your attention, let's get started:","category":"page"},{"location":"intro.html#What-is-Property-Based-Testing?","page":"Introduction to PBT","title":"What is Property Based Testing?","text":"","category":"section"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"Property Based Testing is the idea of checking the correctness of a function, algorithm or calculation against a number of desired properties that function should observe. Consider this function:","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"function foo(a::Int, b::Int)\n    a < 5 && return false\n    b < 5 && return false\n    return true\nend","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"From reading the source code as a user, we can see that","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"a and b must be of type Int\nif either a or b is smaller than 5, the function returns false, otherwise it returns true.","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"So the property that should hold for this function is that if we supply two Int arguments, the function will always tell us whether they are both at least 5. We might define this property for testing purposes like so:","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"function foo_prop()\n    a = rand(Int)\n    b = rand(Int)\n    if a < 5 || b < 5\n        return foo(a,b) == false\n    else\n        return foo(a,b) == true\n    end\nend","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"Every time we run foo_prop, we generate a random input for foo and check whether its output behaves as expected. Written like this, it has a few major drawbacks:","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"Being somewhat certain that we cover the function completely quickly becomes infeasible\nWe have no control over the numbers being generated\nWe can't reuse the way we generate these numbers; expanding a testsuite like this leads to a lot of boilerplate and repetition","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"On its own, just foo_prop is already property based testing - we take some expected input and check it against the expected output/behavior. However, on 64-bit systems, Int has a value in the interval [-9223372036854775808, 9223372036854775807], which is one of 2^64 different values. Considering that our function takes two of those, our input space has 2^2 times 64 distinct pairs of elements! Looping through all of them would take much too long. Worse, we may then need to record the result for each of them to prove later that we actually checked it. With more complex data types, this only grows worse as more different types and combinations of them are involved.","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"This is where a related approach called fuzzing comes in - instead of checking ALL values and giving a 100% guarantee that it works as expected, we only check a sampled subset of all possible values and therefore only receive a probabilistic result. However, this comes with the distinct advantage of being much, much faster than checking all possible values. We trade accuracy for performance (much like we do with floating point values). If our sampling is good enough & representative of the actual data we'd usually expect, this can be a very good indicator for correctness on our input. The difficulty comes from the second point above - controlling the values we put in to a satisfying degree, as well as, once a failure is found, reducing it to something we humans can more easily use to pinpoint the uncovered bug, through a process called \"shrinking\". You can find the introductory explanations for how this works in the context of PropCheck.jl in the Basic Usage section of the examples.","category":"page"},{"location":"intro.html#Julia-specific-nuances","page":"Introduction to PBT","title":"Julia specific nuances","text":"","category":"section"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"Consider this (seemingly!) very trivial function:","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"function add(a,b)\n    a + b\nend","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"Obviously, this function does nothing more than forward its arguments to +. From reading the source code above, we'd expect this to always behave the same as addition - and we'd probably be right! In julia though, a few subtleties come into play:","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"We don't know the type of the input arguments\nWe don't know how many different values each argument can take on\nWe don't know whether + is implemented on whatever we get in the first place\nIf it is, we don't know its implementation and we don't know whether it's correct/as we expect","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"So in reality, purely from reading the source code, we know nothing more about add other than \"passes its argument to +\". This sort of genericity is both a blessing and a curse, in that it allows anyone that has + defined on two types to call our function, while also making it devilishly difficult for us as developers to anticipate all possible behaviors that can occur.","category":"page"},{"location":"intro.html","page":"Introduction to PBT","title":"Introduction to PBT","text":"With property based testing, we should in theory be able to define a set of properties we'd like to hold on our code, for any object that can be passed into our add function. Users of our code who define a new type should be able to take those properties and check the behavior of their type & implementation in our function against the expected properties and find out (at least probabilistically) whether they've implemented the required functions correctly.","category":"page"},{"location":"shrinktrees.html#Shrinking-with-Trees","page":"Shrinking with Trees","title":"Shrinking with Trees","text":"","category":"section"},{"location":"shrinktrees.html","page":"Shrinking with Trees","title":"Shrinking with Trees","text":"In the examples we've learnt about various integrated shrinkers. So how does this work under the hood?","category":"page"},{"location":"shrinktrees.html","page":"Shrinking with Trees","title":"Shrinking with Trees","text":"When we generate a value from an integrated shrinker, we get some Tree out, not the value directly:","category":"page"},{"location":"shrinktrees.html","page":"Shrinking with Trees","title":"Shrinking with Trees","text":"using PropCheck\nnums = PropCheck.isample(1:3);\nt = generate(nums)","category":"page"},{"location":"shrinktrees.html","page":"Shrinking with Trees","title":"Shrinking with Trees","text":"Tree is the main object doing the heavy lifting behind the scenes - all PropCheck.AbstractIntegrated create these objects. A Tree is nothing more than a lazy representation of a root and its shrunk values. You can think of a Tree as a tree with one element at the root, and zero to n values as its children. As the name suggests, we can take a look at these shrink trees with AbstractTrees:","category":"page"},{"location":"shrinktrees.html","page":"Shrinking with Trees","title":"Shrinking with Trees","text":"using AbstractTrees\nprint_tree(t)","category":"page"},{"location":"shrinktrees.html","page":"Shrinking with Trees","title":"Shrinking with Trees","text":"On the left hand side up top we can see our generated root - the initial value 3. One layer to the right, we can see the first level of shrinks of 3. These values have been produced by the default shrinking function shrink that is passed to isample - they observe the property that their absolute value is strictly less than the value of our root, in order to guarantee that their shrunk values in turn don't ever generate the original value (in this case, 3) again. In addition, the default shrinking function also guarantees that the shrunk values are larger than the minimum of the given range; hence, the smallest number that can be generated is 1.","category":"page"},{"location":"shrinktrees.html","page":"Shrinking with Trees","title":"Shrinking with Trees","text":"The magic behind PropCheck.jl is in this Tree object, which is heavily inspired by the Hedgehog  Haskell library for property based testing.","category":"page"},{"location":"shrinktrees.html","page":"Shrinking with Trees","title":"Shrinking with Trees","text":"Under the hood, this is what PropCheck.jl manipulates. When you filter an integrated shrinker, you implicitly filter the Tree produced by the shrinker:","category":"page"},{"location":"shrinktrees.html","page":"Shrinking with Trees","title":"Shrinking with Trees","text":"t = generate(filter(iseven, PropCheck.ival(3)))\nprint_tree(t)","category":"page"},{"location":"shrinktrees.html","page":"Shrinking with Trees","title":"Shrinking with Trees","text":"and when you map over an integrated shrinker, you map over the Tree it produces:","category":"page"},{"location":"shrinktrees.html","page":"Shrinking with Trees","title":"Shrinking with Trees","text":"t = generate(map(sqrt∘Complex, nums))\nprint_tree(t)","category":"page"},{"location":"shrinktrees.html","page":"Shrinking with Trees","title":"Shrinking with Trees","text":"When searching for a counterexample, PropCheck.jl first generates a number of possible roots, and when one of those roots makes your property fail, it tries to find a smaller (i.e., a shrunk) value that still reproduces the same failure. Those shrunk values all originate from the Tree spun out by repeatedly expanding the root of the Tree, according to the map, filter, generating constraints of the integrated shrinkers and the shrinking functions associated with them.","category":"page"},{"location":"shrinktrees.html","page":"Shrinking with Trees","title":"Shrinking with Trees","text":"It's important to keep this shrink Tree in mind when generating - the larger the tree is you span out with evermore complex generation, the harder it can be for PropCheck.jl to find the smaller counterexamples you're looking for.","category":"page"},{"location":"faq.html#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq.html#What-exactly-is-\"shrinking\"?","page":"FAQ","title":"What exactly is \"shrinking\"?","text":"","category":"section"},{"location":"faq.html","page":"FAQ","title":"FAQ","text":"And the related questions, \"What is being minimized when shrinking? What is the figure of merit?\", originally asked here.","category":"page"},{"location":"faq.html","page":"FAQ","title":"FAQ","text":"Measuring shrinking values is a bit difficult - after all, the goal is to create a smaller (to human eyes) instance of the given type. It's very subjective what that means, but there are some generalities you can apply. For example, a 0.0 is less \"complex\" of a value than 1234651.3465, so it's usually considered smaller for shrinking purposes. Similarly, an array with just 2 values is generally considered simpler/smaller than an array with 4123 values, even if both arrays otherwise exhibit the same properties.","category":"page"},{"location":"faq.html","page":"FAQ","title":"FAQ","text":"Expanding on that - consider checking whether all arrays of positive integers are sorted. Surely, there are lots of counterexamples to that, like [164, 45, 128, 202, 87], [5,3,2,1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], but there's only one example that's minimal: [1, 0], the array with minimal values and minimal length.","category":"page"},{"location":"faq.html","page":"FAQ","title":"FAQ","text":"This is of course not correct for all properties and all value domains; the \"minimal counterexample\" can  look quite different depending on what kind of values you're mostly interested in. For example, if you're interested in finding the smallest possible counterexample for arrays of Int8, it'll be [-127, -128], because the smallest possible counterexample numerically is a negative number with larger absolute value. By default, PropCheck won't give you that, because a smaller absolute value is usually more desirable for humans to think about; the bitpattern underlying the number is simpler (or shorter, if you remove leading zeros). To have PropCheck give you those smaller numerical shrinks, you simply give e.g. itype a shrinking function producing those values:","category":"page"},{"location":"faq.html","page":"FAQ","title":"FAQ","text":"julia> using PropCheck\n\njulia> vect = PropCheck.vector(ival(4), itype(Int8, PropCheck.shrinkTowards(typemin(Int8))));\n\njulia> check(issorted, vect)\n┌ Info: Found counterexample for 'issorted', beginning shrinking...\n│   Counterexample =\n│    4-element Vector{Int8}:\n│      -2\n│      58\n│      21\n└     -85\n[ Info: 32 counterexamples found\n2-element Vector{Int8}:\n -127\n -128","category":"page"},{"location":"faq.html","page":"FAQ","title":"FAQ","text":"shrinkTowards currently only has definitions for numeric types (<: Integer, <: AbstractFloat, Bool) because shrinking towards a general object is quite a bit harder - e.g. shrinking towards a given string could be an option by working through inserts, deletions & character changes, but I'll have to think about how to best do that to make sure the full possible space between a given source & target string is generateable.","category":"page"},{"location":"faq.html","page":"FAQ","title":"FAQ","text":"What is being minimized when shrinking? What is the figure of merit?","category":"page"},{"location":"faq.html","page":"FAQ","title":"FAQ","text":"Circling back around to your question - anything you want, really! With a custom shrinking function (which you can supply to everything that generates a value), YOU get to decide how you want to shrink/minimize things. PropCheck.jl just tries to give you some sane defaults for types from Base (or at least, those I've gotten around to implementing generate and shrink for). E.g. in Composing Generators, I use PropCheck.noshrink to make sure some strings don't shrink when shrinking the object the generator is used in, because looking at a student with a name is nicer than looking at a student with the empty string as a name. This is generally applicable with any custom shrinking function; whichever values you consider to be smaller for the purpose of that shrinking function are what PropCheck.jl considers \"smaller\" (which is also why it's important that shrinking functions can't produce shrinking loops - i.e. a shrinking function must never produce a value that, when shrunk with the same shrinking function again, could lead to the initial value).","category":"page"},{"location":"faq.html#What-about-formal-specifications?","page":"FAQ","title":"What about formal specifications?","text":"","category":"section"},{"location":"faq.html","page":"FAQ","title":"FAQ","text":"While efforts regarding formal specifications & machine checkable proofs are comendable, I think we can get quite far with property based testing & fuzzing before we need to tackle the dragon that is formal methods & verification. PropCheck.jl is decidedly not in the formal verification camp - it's not an interface to SAT or SMT solvers, but a fuzzer. Said differently, property based testing + fuzzing are a fuzzy, statistical subset of full formal verification. You can think of running fuzzing tests as increasing confidence in the correctness of your code each time you run your testsuite, due to different inputs being chosen.","category":"page"},{"location":"faq.html","page":"FAQ","title":"FAQ","text":"That being said, if this package becomes obsolete due to tremendous advances in formal methods & verification in Julia, I'll happily retire this package to the annals of history :)","category":"page"},{"location":"faq.html#What-about-package-XYZ?","page":"FAQ","title":"What about package XYZ?","text":"","category":"section"},{"location":"faq.html","page":"FAQ","title":"FAQ","text":"There are a number of other codebases related to property based testing (for example, JCheck.jl, QuickCheck.jl or RandomizedPropertyTest.jl) but to my eyes, they are either very old (10+ years!) and don't support modern Julia, don't support shrinking or don't really compose their generators well, due to being based on QuickCheck. PropCheck.jl, while certainly taking inspiration from QuickCheck, is using a mixed approach, focusing on integrated shrinking. This has advantages and disadvantages, but from my experience with the package so far, the current architecture is pretty extensible and works much better than a plain implementation of QuickCheck (Julia is much less focused on types than Haskell is, after all; much of the information we have about a type is implicit & not guaranteed, and even with that, some type based shrinks are just plain bad, due to even their types not capturing the full semantics of the produced values). Most of the features currently in PropCheck.jl came about because I ran into an issue that I wanted to solve when testing a different codebase - a workflow I don't expect to change too much in the future.","category":"page"},{"location":"api.html#API","page":"API Reference","title":"API","text":"","category":"section"},{"location":"api.html#Function-Index","page":"API Reference","title":"Function Index","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"warning: Stability\nThe entries written on this page are automatically generated and DO NOT represent the currently supported API surface. PropCheck.jl is currently in a 0.x release; feel free to use anything you can find here, but know that (for now) only symbols that are exported are expected to stick around (they too may change, but I don't expect the underlying functionality to vanish entirely).Nevertheless, I don't really expect things to change too much - the package is already complicated as is.","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api.html#Function-reference","page":"API Reference","title":"Function reference","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Modules = [PropCheck]\nOrder = [:function, :type]\nFilter = t -> begin\n    !(isabstracttype(t) && t <: PropCheck.AbstractIntegrated) && !(t in (PropCheck.shrink, PropCheck.generate, PropCheck.itype))\nend","category":"page"},{"location":"api.html#Base.Iterators.map-Union{Tuple{T}, Tuple{Any, PropCheck.Tree{T}}} where T","page":"API Reference","title":"Base.Iterators.map","text":"map(f, ::Tree)\n\nMaps the function f over the nodes of the given Tree, returning a new true.\n\nThe subtrees of the tree returned by map are guaranteed to be unique.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.filter-Union{Tuple{T}, Tuple{Any, PropCheck.AbstractIntegrated{T}}, Tuple{Any, PropCheck.AbstractIntegrated{T}, Any}} where T","page":"API Reference","title":"Base.filter","text":"filter(p, i::AbstractIntegrated[, trim=false]) -> AbstractIntegrated\n\nFilters i lazily such that all elements contained fulfill the predicate p, i.e. all elements for which p is false are removed.\n\ntrim controls whether subtrees are removed completely when the root doesn't fulfill the predicate or whether only that root should be skipped, still trying to shrink its subtrees. This trades performance (less shrinks to check) for quality (fewer/less diverse shrink values tried).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.filter-Union{Tuple{T}, Tuple{Any, PropCheck.Tree{T}}, Tuple{Any, PropCheck.Tree{T}, Any}} where T","page":"API Reference","title":"Base.filter","text":"filter(pred, ::Tree, trim=false)\n\nFilters the given Tree by applying the predicate pred to each root.\n\nFiltering is done lazily for subtrees.\n\ntrim controls whether subtrees that don't match the predicate should be pruned entirely, or only their roots should be removed from the resulting Tree. If trim is true, subtrees of subtrees that don't match the predicate are moved to the parent.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.map-Union{Tuple{F}, Tuple{T}, Tuple{F, PropCheck.AbstractIntegrated{T}}} where {T, F}","page":"API Reference","title":"Base.map","text":"map(f, i::AbstractIntegrated) -> AbstractIntegrated\n\nMaps f lazily over all elements in i, producing an AbstractIntegrated generating the mapped values.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.array-Union{Tuple{TP}, Tuple{T}, Tuple{PropCheck.AbstractIntegrated{PropCheck.Tree{TP}}, PropCheck.AbstractIntegrated{PropCheck.Tree{T}}}} where {T, TP<:(Tuple{Vararg{T, N}} where {N, T})}","page":"API Reference","title":"PropCheck.array","text":"PropCheck.array(genSize::AbstractIntegrated, genA::AbstractIntegrated{Tree{T}}) where T\n\nA utility function for creating an integrated shrinker producing Array{T, N}, with its size controlled by the tuple generated from genLen and its elements created by genA. If genSize produces an integer instead of a tuple of integers, this function will produce a Vector instead.\n\nThis is generally the best way to create a shrinkable array, as it takes shrinking both size & elements into account, irrespective of shrinking order.\n\nnote: FiniteIntegrated\nUsing a FiniteIntegrated{T} for the elements will cause the array to have Union{Nothing, T} as its eltype, because they may stop generating T at any point!\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.assemble-Union{Tuple{T}, Tuple{I}, Tuple{Type{T}, I, I, I}} where {I, T<:Union{Float16, Float32, Float64}}","page":"API Reference","title":"PropCheck.assemble","text":"assemble(::T, sign::I, expo::I, frac::I) where {I, T <: Union{Float16, Float32, Float64}} -> T\n\nAssembles sign, expo and frac arguments into the floating point number of type T it represents. sizeof(T) must match sizeof(I).\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.bind!-Union{Tuple{T}, Tuple{PropCheck.IntegratedBoundedRec{T}, PropCheck.AbstractIntegrated}} where T","page":"API Reference","title":"PropCheck.bind!","text":"bind!(ibr::IntegratedBoundedRec{T}, ai::AbstractIntegrated{T})\n\nBinds the given AbstractIntegrated to ibr, such that it will be called for generation when generate(ibr) is called.\n\nThis needs to be called to allow mutual recursion during generation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.check-Union{Tuple{T}, Tuple{Any, PropCheck.AbstractIntegrated{T}}, Tuple{Any, PropCheck.AbstractIntegrated{T}, Random.AbstractRNG}} where T","page":"API Reference","title":"PropCheck.check","text":"check(p, i::AbstractIntegrated[, rng::AbstractRNG=Random.default_rng()];\n         ntests::Int=PropCheck.numTest[], show_initial=true, transform=identity)\n\nChecks whether the boolean predicate function p returns true for all values generated by i.\n\nKeyword arguments:\n\nntests: How many values to generate & check\nshow_initial: Whether to show the initial failing example in the printed @info message\ntransform: an optional transforming function to apply before returning a failure case\nThis can be used to make a given value, like a floating point NaN, easier to inspect & reproduce\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.extent-Tuple{PropCheck.ExtentIntegrated}","page":"API Reference","title":"PropCheck.extent","text":"extent(::ExtentIntegrated) -> Tuple{T,T} where T\n\nGives a tuple of the upper & lower bound of this ExtentIntegrated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.freeze-Tuple{PropCheck.AbstractIntegrated}","page":"API Reference","title":"PropCheck.freeze","text":"freeze(::T) where T <: AbstractIntegrated -> T\n\n\"Freezes\" an AbstractIntegrated by returning a new object that has a generate method, and can be wrapped in a new integrated shrinker.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.iconst-Tuple{Any}","page":"API Reference","title":"PropCheck.iconst","text":"iconst(x) -> AbstractIntegrated\n\nA convenience constructor for creating an integrated shrinker.\n\nTrees created by this do not shrink, and generate on the returned AbstractIntegrated will always produce x.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.ifloat-Union{Tuple{Type{T}}, Tuple{T}} where T<:Union{Float16, Float32, Float64}","page":"API Reference","title":"PropCheck.ifloat","text":"ifloat(::T) where T <: Union{Float16, Float32, Float64}\n\nAn integrated shrinker producing floating point values, except NaNs and Infs.\n\ninfo: NaN & Inf\nThere are multiple valid bitpatterns for both NaN- and Inf-like values. This shrinker is guaranteed not to produce any of them of its own volition. However, functions running on the values produced by this shrinker may still result in NaN or Inf to be produced. For example, if this shrinker produces a 0.0 and that number is passed to x -> 1.0/x, you'll still get a Inf. This can be important for mapping over this shrinker.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.ifloatinf-Union{Tuple{Type{T}}, Tuple{T}} where T<:Union{Float16, Float32, Float64}","page":"API Reference","title":"PropCheck.ifloatinf","text":"ifloatinf(::Type{T}) where T <: Union{Float16, Float32, Float64}\n\nAn integrated shrinker producing nothing but valid Infs.\n\nSee also ifloatnan, ifloatinfnan.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.ifloatinfnan-Union{Tuple{Type{T}}, Tuple{T}} where T<:Union{Float16, Float32, Float64}","page":"API Reference","title":"PropCheck.ifloatinfnan","text":"ifloatinfnan(::Type{T}) where T <: Union{Float16, Float32, Float64}\n\nAn integrated shrinker producing nothing but valid NaNs and Infs.\n\nImplemented more efficiently than naive combining of ifloatnan and ifloatinf.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.ifloatnan-Union{Tuple{Type{T}}, Tuple{T}} where T<:Union{Float16, Float32, Float64}","page":"API Reference","title":"PropCheck.ifloatnan","text":"ifloatnan(::T) where T <: Union{Float16, Float32, Float64}\n\nAn integrated shrinker producing nothing but valid NaNs.\n\nSee also ifloatinf, ifloatinfnan.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.inegint-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T}, Any}} where T<:Union{Int128, Int16, Int32, Int64, Int8}","page":"API Reference","title":"PropCheck.inegint","text":"inegint(::Type{T}[, shrink=shrink]) where T <: Union{Int8, Int16, Int32, Int64, Int128}\n\nAn integrated shrinker producing negative values of type T.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.iposint-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T}, Any}} where T<:Union{Int128, Int16, Int32, Int64, Int8}","page":"API Reference","title":"PropCheck.iposint","text":"iposint(::Type{T}[, shrink=shrink]) where T <: Union{Int8, Int16, Int32, Int64, Int128}\n\nAn integrated shrinker producing positive values of type T.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.isample","page":"API Reference","title":"PropCheck.isample","text":"isample(x[, shrink=shrink]) -> AbstractIntegrated\n\nA convenience constructor for creating an integrated shrinker.\n\nTrees created by this shrink according to shrink, and generate on the returned Integrated will always produce an element of the collection x.\n\nx needs to be indexable.\n\n\n\n\n\n","category":"function"},{"location":"api.html#PropCheck.isample-2","page":"API Reference","title":"PropCheck.isample","text":"isample(x::AbstractRange[, shrink=shrinkTowards(first(x))]) -> AbstractIntegrated\n\nA convenience constructor for creating an integrated shrinker.\n\nTrees created by this shrink towards the first element of the range by default.\n\n\n\n\n\n","category":"function"},{"location":"api.html#PropCheck.iunique-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Any}} where T","page":"API Reference","title":"PropCheck.iunique","text":"iunique(x::Vector, shrink=shrink) -> AbstractIntegrated\n\nA convenience constructor for creating an integrated shrinker.\n\nThis shrinker produces all unique values of x before producing a value it has produced before. The produced trees shrink according to shrink.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.ival-Union{Tuple{T}, Tuple{T, Any}} where T","page":"API Reference","title":"PropCheck.ival","text":"ival(x::T[, shrink=shrink]) -> AbstractIntegrated\n\nA convenience constructor for creating integrated shrinkers, generating their values from a starting value.\n\nTrees created by this function will always initially have x at their root, as well as shrink according to shrink.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.nanHash","page":"API Reference","title":"PropCheck.nanHash","text":"nanHash(x[, h=zero(UInt)])\n\nProduces a hash for values, with special consideration for NaNs, ensuring distinct bitpatterns in NaN produce different hashes.\n\n\n\n\n\n","category":"function"},{"location":"api.html#PropCheck.noshrink-Tuple{T} where T","page":"API Reference","title":"PropCheck.noshrink","text":"noshrink(_::T) -> T[]\n\nA shrinker that doesn't shrink its arguments.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.root-Tuple{PropCheck.Tree}","page":"API Reference","title":"PropCheck.root","text":"root(t::Tree)\n\nReturns the singular root of the given Tree.\n\nSee also subtrees.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.shrinkTowards","page":"API Reference","title":"PropCheck.shrinkTowards","text":"shrinkTowards(to::T) -> (x::T -> T[...])\n\nConstructs a shrinker function that shrinks given values towards to.\n\n\n\n\n\n","category":"function"},{"location":"api.html#PropCheck.str","page":"API Reference","title":"PropCheck.str","text":"str(len::ExtentIntegrated[, alphabet::AbstractIntegrated])\n\nGenerates a string using the given genLen as a generator for the length. The default alphabet is typemin(Char):\"\"[1], which is all representable Char values.\n\n\n\n\n\n","category":"function"},{"location":"api.html#PropCheck.subtrees-Tuple{PropCheck.Tree}","page":"API Reference","title":"PropCheck.subtrees","text":"subtrees(t::Tree)\n\nReturns the (potentially lazy) subtrees of the given Tree.\n\nSee also root.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.tear-Tuple{T} where T<:Union{Float16, Float32, Float64}","page":"API Reference","title":"PropCheck.tear","text":"tear(x::T) where T <: Union{Float16, Float32, Float64} -> Tuple{I, I, I}\n\nReturns the sign, exponent and fractional parts of a floating point number. The returned tuple consists of three unsigned integer types I of the same bitwidth as T.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.tuple-Union{Tuple{T}, Tuple{PropCheck.AbstractIntegrated, PropCheck.AbstractIntegrated{PropCheck.Tree{T}}}} where T","page":"API Reference","title":"PropCheck.tuple","text":"tuple(genLen::AbstractIntegrated, genA::AbstractIntegrated)\n\nGenerates a tuple of a generated length, using the elements produced by genA.\n\nnote: FiniteIntegrated\nUsing a FiniteIntegrated{T} will cause the tuple to have Union{Nothing, T} as its eltype, because they may stop generating T at any point!\n\nwarning: Type stability\nDue to the length produced by genLen not being known until runtime, this function is by its very nature type unstable. Consider using interleave and a fixed number of known generators instead.\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.unfold-Union{Tuple{T}, Tuple{Any, T}} where T","page":"API Reference","title":"PropCheck.unfold","text":"unfold(f, root)\n\nUnfolds root into a Tree, by applying f to each root to create subtrees.\n\nroot is the new root of the returned Tree. f must return an iterable object with eltype egal to typeof(root).\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.vector-Union{Tuple{T}, Tuple{PropCheck.ExtentIntegrated, PropCheck.AbstractIntegrated{T}}} where T","page":"API Reference","title":"PropCheck.vector","text":"PropCheck.vector(genLen::ExtentIntegrated, genA::AbstractIntegrated{Tree{T}}) where T\n\nA utility function for creating an integrated shrinker producing Vector{T}, with its length controlled by the number generated from genLen and its elements created by genA.\n\nThis is generally the best way to create a shrinkable vector, as it takes shrinking both length & elements into account, irrespective of shrinking order.\n\nnote: FiniteIntegrated\nUsing a FiniteIntegrated{T} for the elements will cause the vector to have Union{Nothing, T} as its eltype in the general case, because they may stop generating T at any point!\n\n\n\n\n\n","category":"method"},{"location":"api.html#PropCheck.Flatten","page":"API Reference","title":"PropCheck.Flatten","text":"Flatten{Eltype}\n\nAn iterator like Base.flatten, except with inferrable eltype. Requires the given iterators to have the same eltype.\n\nwarning: Type mismatches\nThe given Eltype is used to assert the return type; a type mismatch there will throw.\n\n\n\n\n\n","category":"type"},{"location":"api.html#PropCheck.Integrated","page":"API Reference","title":"PropCheck.Integrated","text":"Integrated{T} <: InfiniteIntegrated{T}\n\nA naive integrated shrinker, only providing extremely basic functionality for generating and shrinking Trees. Default fallback if no other, more specialized type exists.\n\nwarning: Pending Redesign\nThis type is likely going to be redesigned in the future. Methods constructing it are not stable, and may be removed at any point.\n\n\n\n\n\n","category":"type"},{"location":"api.html#PropCheck.IntegratedBoundedRec","page":"API Reference","title":"PropCheck.IntegratedBoundedRec","text":"IntegratedBoundedRec{T}(maxrec)\nIntegratedBoundedRec(maxrec, ai::AbstractIntegrated)\nIntegratedBoundedRec{T} <: AbstractIntegrated{T}\n\nAn AbstractIntegrated for allowing mutual recursion between two AbstractIntegrated. Used by inserting as a shim into one AbstractIntegrated, creating a second AbstractIntegrated and setting the second one as bind!(::IntegratedBoundedRec, ::AbstractIntegrated) of the shim afterwards.\n\nnote: Mutual recursion\nThis type is for allowing mutual recursion between two (or more) different integrated shrinkers. Selfrecursion could also be done through this, but is likely to be more efficient when implemented explicitly (or bounded through other means), due to the need for type instability on self recursion as a result of how this type is implemented.\n\n\n\n\n\n","category":"type"},{"location":"api.html#PropCheck.IntegratedChain","page":"API Reference","title":"PropCheck.IntegratedChain","text":"ChainIntegrated(is::AbstractIntegrated...)\nChainIntegrated{Eltype, N, Is, Finite} where {Eltype, N,\n                                        Is <: NTuple{N, <:AbstractIntegrated}, Finite} <: AbstractIntegrated{Eltype}\n\nAn integrated shrinker chaining together a number of given integrated shrinkers, producing the values they generate one after another.\n\nAll except the last argument must have some finite length, meaning the integrated shrinker must subtype FiniteIntegrated. Only the last integrated shrinker is allowed to be only <: InfiniteIntegrated.\n\nThe values produced by this integrated shrinker shrink according to the shrinking function given to the shrinker that originally produce them.\n\nThe Finite type parameter is a Bool, indicating whether this IntegratedChain is finite or not.\n\n\n\n\n\n","category":"type"},{"location":"api.html#PropCheck.IntegratedChoice","page":"API Reference","title":"PropCheck.IntegratedChoice","text":"IntegratedChoice(is::AbstractIntegrated...)\nIntegratedChoice{T} <: AbstractIntegrated{T}\n\nAn integrated shrinker for generating a value from one of any number of given AbstractIntegrated. The choice is taking uniformly random. No consideration for repeats is taken.\n\nIs <: AbstractIntegrated{T}, but can behave (except for dispatch) like a FiniteIntegrated, if all given AbstractIntegrated are FiniteIntegrated.\n\n\n\n\n\n","category":"type"},{"location":"api.html#PropCheck.IntegratedConst","page":"API Reference","title":"PropCheck.IntegratedConst","text":"IntegratedConst{T,R,G} <: ExtentIntegrated{T}\n\nAn integrated shrinker describing a constant. The shrinker will always produce that value, which doesn't shrink.\n\n\n\n\n\n","category":"type"},{"location":"api.html#PropCheck.IntegratedFiniteIterator","page":"API Reference","title":"PropCheck.IntegratedFiniteIterator","text":"IntegratedFiniteIterator(itr[, shrink=shrink])\nIntegratedFiniteIterator{T} <: FiniteIntegrated{T}\n\nAn integrated shrinker taking arbitrary iterables that have a length or a shape. Once the iterator is exhausted, the integrated shrinker produces nothing.\n\nThe values produced by this integrated shrinker shrink according to the given shrinking function.\n\n\n\n\n\n","category":"type"},{"location":"api.html#PropCheck.IntegratedLengthBounded","page":"API Reference","title":"PropCheck.IntegratedLengthBounded","text":"IntegratedLengthBounded(is::AI, bound::Integer) where {T, AI <: AbstractIntegrated{T}}\nIntegratedLengthBounded{T, AbstractIntegrated{T}} <: FiniteIntegrated{T}\n\nAn integrated shrinker bounding the number of values generated by the passed integrated shrinker. This has the ability to transform any AbstractIntegrated into a FiniteIntegrated.\n\nThe given bound must be a positive value. If a fi::FiniteIntegrated is given as the integrated shrinker, the bound is chosen to be min(length(fi), bound).\n\nThe values produced by this integrated shrinker shrink according to the shrinking function given to the original integrated shrinker wrapped by IntegratedLengthBounded.\n\n\n\n\n\n","category":"type"},{"location":"api.html#PropCheck.IntegratedOnce","page":"API Reference","title":"PropCheck.IntegratedOnce","text":"IntegratedOnce(el[, shrink=shrink])\nIntegratedOnce{T} <: FiniteIntegrated{T}\n\nAn integrated shrinker that produces a shrink tree with the value el at its root exactly once. Afterwards, the integrated shrinker produces nothing.\n\n\n\n\n\n","category":"type"},{"location":"api.html#PropCheck.IntegratedRange","page":"API Reference","title":"PropCheck.IntegratedRange","text":"IntegratedRange{T,R,G,F} <: ExtentIntegrated{T}\n\nAn integrated shrinker describing a range of values.\n\nThe values created by this shrinker shrink according to the given shrinking function. The shrinking function must ensure that the produced values are always contained within the bounds of the given range.\n\n\n\n\n\n","category":"type"},{"location":"api.html#PropCheck.IntegratedUnique","page":"API Reference","title":"PropCheck.IntegratedUnique","text":"IntegratedUnique(vec::Vector{ElT}[, shrink=shrink::S]) where {ElT,S}\nIntegratedUnique{T,ElT,S} <: InfiniteIntegrated{T}\n\nAn integrated shrinker, taking a vector vec. The shrinker will produce all unique values of vec in a random order before producing a value it returned before. The values produced by this shrinker shrink according to shrink.\n\n\n\n\n\n","category":"type"},{"location":"api.html#PropCheck.IntegratedVal","page":"API Reference","title":"PropCheck.IntegratedVal","text":"IntegratedVal(val::V, shrink::S) where {V,S}\nIntegratedVal{T,V,S} <: InfiniteIntegrated{T}\n\nAn integrated shrinker, taking a value val. The shrinker will always produce val, which shrinks according to shrink.\n\nIf V <: Number, shrinking functions given to this must produce values in\n\n[typemin(V), v] if v > zero(V)\n[v, typemax(V)] if v < zero(V)\nno values if iszero(v)\n\nThis shrinker supports extent out of the box if V <: Number. For other types, you need to define extent(::IntegratedVal{Tree{T}})\n\n\n\n\n\n","category":"type"},{"location":"api.html#PropCheck.Tree","page":"API Reference","title":"PropCheck.Tree","text":"Tree{T}\n\nA tree of T objects. The tree is inherently lazy; subtrees of subtrees are only generated on demand.\n\nThe subtrees field is intentionally untyped, to allow for various kinds of lazy subtree representations.\n\n\n\n\n\n","category":"type"},{"location":"api.html#PropCheck.UniqueIterator","page":"API Reference","title":"PropCheck.UniqueIterator","text":"UniqueIterator(itr, by=identity)\n\nA lazy iterator over unique elements that have not been produced before.\n\nwarning: Floating Point\nThis iterator treats distinct bitpatterns of NaN as distinct values, unlike Base.hash.\n\n\n\n\n\n","category":"type"},{"location":"Examples/containers.html#Generating-Containers","page":"Generating Containers","title":"Generating Containers","text":"","category":"section"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"So far we've only looked at generating objects from their types or simple structs, but this can become difficult when we're trying to generate more complicated objects like tuples or arrays with a generated size. After all, there is not a unique vector with a fixed length that has the type Vector{Int}, for example - all vectors containing Int, regardless of their length, have the same type. A similar thing is true for tuples if we don't know their length ahead of time and we want to generate that length as well.","category":"page"},{"location":"Examples/containers.html#Generating-tuples","page":"Generating Containers","title":"Generating tuples","text":"","category":"section"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"We're going to start by generating homogenous tuples of things. PropCheck.jl provides a convenience function for this: PropCheck.tuple(n, gen).","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"Consider this property:","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"using PropCheck\n\nprop(x) = all(<(5), x)","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"This property tests whether all elements of the argument are smaller than 5.","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"In order to test that all tuples we can conceivably think of obey this property (or produce a counterexample!), we use tuple. Its first argument is a generator for a number to use as the length, and the second argument a generator for the objects contained within the tuple. The simplest generator for a length is a generator that just returns its given argument, called iconst:","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"const_sized_tuple = PropCheck.tuple(iconst(3), itype(Int8));\ntree = generate(const_sized_tuple)","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"And indeed, the generated size of the tuple is 3. Checking the values this tree shrinks to, we can see that they too are of size 3:","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"all(t -> length(root(t)) == 3, subtrees(tree))\nusing Random: shuffle!\nshuffle!(collect(subtrees(tree)))[1:5]","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"I'm only showing a subset of all generated subtrees because the full list is quite long. Nevertheless, if we put our generator into check to test our property:","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"check(prop, const_sized_tuple)","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"PropCheck.jl successfully reduces the first failing test case to one where no elements can be shrunk further without making the test pass, giving us our smallest possible counterexample - a tuple with all zeros, except for one place which has 5 instead. There are three of these minimal cases for prop: (5,0,0), (0,5,0) and (0,0,5). In general, there may be much more than these three minimal cases, and yet again more cases that are not minimal at all.","category":"page"},{"location":"Examples/containers.html#Variable-size-tuples","page":"Generating Containers","title":"Variable size tuples","text":"","category":"section"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"You may notice that the tuple is always of size 3, never smaller - the reasoning for this behavior is twofold:","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"Tuples generally don't change their size - they are immutable containers, and as such manipulating them will create a new tuple altogether.\nTuples are created during generation when you require a constant number of things, but want to still shrink the things themselves.","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"But what if we truly do want to generate tuples of various sizes, for example because we want to test some recursive reduction over them?","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"This too is simple - we only have to change the generator passed into tuple to one that can produce multiple distinct values, like isample:","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"using PropCheck # hide\nvariable_size_tuple = PropCheck.tuple(isample(0:10), itype(Int8));\n[ generate(variable_size_tuple) for _ in 1:5 ]","category":"page"},{"location":"Examples/containers.html#Generating-vectors","page":"Generating Containers","title":"Generating vectors","text":"","category":"section"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"Similar to tuples, there is also PropCheck.vector(n, gen) to get a generator which generates Vectors of n elements:","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"using PropCheck\nvec = PropCheck.vector(iconst(3), itype(Int8));","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"Which we can then run against the prop from earlier:","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"julia> prop(x) = all(<(5), x)\nprop (generic function with 1 method)\n\njulia> check(prop, vec)\n┌ Info: Found counterexample for 'prop', beginning shrinking...\n│   Counterexample =\n│    3-element Vector{Int8}:\n│     -62\n│      57\n└      81\n[ Info: 7 counterexamples found for prop\n3-element Vector{Int8}:\n 0\n 0\n 5","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"though for a Vector, a constant size of 3 is of course not minimal. We can do better here, by allowing the vector to shrink its length. There are multiple options for achieving this:","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"isample, which samples from a collection v\nival, which always produces the same value (like iconst), but allows it to shrink","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"The former is mostly useful when we don't care about the exact element we generate, but would like it to be from some defined collection of values, while the latter is useful when we want to start out with some value, but are fine with shrinks of that value as well. isample has the additional ability to limit values generated from a range to stay limited to that range.","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"For example, if we use ival(3) for the length of our vector:","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"valvec = PropCheck.vector(ival(3), itype(Int8));\n[ generate(valvec) for _ in 1:5 ]","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"We can see that they all start out as vectors of length 3, but their subtrees can be smaller too:","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"subs = collect(subtrees(generate(valvec)));\nfilter(v -> length(root(v)) < 3, subs)","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"If we use isample instead of ival, we can see that, just as with tuples, the initial value has a size depending on what we sampled from:","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"samplevec = PropCheck.vector(isample(0:5), itype(Int8));\n[ generate(samplevec) for _ in 1:5 ]","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"and subsequently, the minimal counterexample also changes, to the vector containing nothing but 5:","category":"page"},{"location":"Examples/containers.html","page":"Generating Containers","title":"Generating Containers","text":"julia> check(prop, valvec; show_initial=false)\n[ Info: Found counterexample for 'prop', beginning shrinking...\n[ Info: 7 counterexamples found for prop\n1-element Vector{Int8}:\n 5\n\njulia> check(prop, samplevec; show_initial=false)\n[ Info: Found counterexample for 'prop', beginning shrinking...\n[ Info: 9 counterexamples found for prop\n1-element Vector{Int8}:\n 5","category":"page"},{"location":"index.html#PropCheck.jl-Documentation","page":"Main Page","title":"PropCheck.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"Main Page","title":"Main Page","text":"This is the documentation for PropCheck.jl, a property based testing framework loosely inspired by QuickCheck & Hedgehog.","category":"page"},{"location":"index.html","page":"Main Page","title":"Main Page","text":"It features integrated shrinkers, which can smartly shrink initial failures to smaller examples while preserving the invariants the original input was generated under.","category":"page"},{"location":"index.html","page":"Main Page","title":"Main Page","text":"Check out the Examples in the sidebar to get an introduction to property based testing and to learn how to write your own tests!","category":"page"},{"location":"index.html","page":"Main Page","title":"Main Page","text":"Here's also a sitemap for the rest of the documentation:","category":"page"},{"location":"index.html","page":"Main Page","title":"Main Page","text":"Pages = [\"index.md\", \"intro.md\", \"shrinktrees.md\", \"faq.md\", \"interfaces.md\", \"api.md\"]\nDepth = 3","category":"page"},{"location":"index.html#Goals","page":"Main Page","title":"Goals","text":"","category":"section"},{"location":"index.html","page":"Main Page","title":"Main Page","text":"Good performance\nA test framework should not be the bottleneck of the testsuite.\nComposability\nIt should not be required to modify an existing codebase to accomodate PropCheck.jl\nPropCheck.jl should merely be a way of writing some tests for arbitrary functions, not something you need to integrate into your code.\nReusability\nIt should be possible to reuse large parts of the existing definitions for Base to build custom integrated shrinkers/generators","category":"page"},{"location":"index.html#Limitations","page":"Main Page","title":"Limitations","text":"","category":"section"},{"location":"index.html","page":"Main Page","title":"Main Page","text":"Due to threading being a hard problem, I have not yet looked into parallelizing the running of PropCheck.jl.\nI think something like this should be handled by the test runner, not PropCheck.jl.\nThis might also interfere with threading in the code-to-be-tested.\nPropCheck.jl (currently) cannot test temporal properties (well).\nIt's not impossible to do so, but since PropCheck is not an intrusive testing framework, it has no control over how long tasks take to run, whether they throw spurious errors etc.\nI would like to be able to test that as well, but this is (currently) out of scope.","category":"page"},{"location":"index.html#Planned-Features","page":"Main Page","title":"Planned Features","text":"","category":"section"},{"location":"index.html","page":"Main Page","title":"Main Page","text":"Reflection on methods, for creating arbitrary generators from function definitions\nSee issue #3 tracking this.\nReintroducing generation of Any\nSee issue #4 tracking this.\nBetter handling of errors during generation of values\nPerhaps there's a way to automatically detect error paths and skip generating values that would lead to an error?\nSee issue #5 tracking this.\nBetter handling of errors during testing\nIt would be great if we could shrink on the specific type & message of an error as well\nRight now, all failures due to an error assume all errors are the same\nSee issue #6 tracking this.\nBetter way to define default generators\nRight now, an itype(Int) assumes all Ints are equally important - this is not always the case\nIntegers that are branched on that are close to the critical edge when a condition in that branch flips from true to false are usually more interesting, but that's not knowable just from itype(Int) itself.\nI'd call such a generator \"function aware\" or \"function integrated\".\nThis extends to all kinds of properties, like the length of an array, whether a field in some object is set or not etc.\nThis is a very difficult problem, so please don't expect anything of the sort anytime soon. It's just a thought stuck in my head.\nSee issue #7 tracking this.","category":"page"},{"location":"Examples/structs.html#Generating-Structs","page":"Generating Structs","title":"Generating Structs","text":"","category":"section"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"While we can get pretty far with generating basic types like Int or String, sometimes we need to make additional guarantees or don't need to generate the full spectrum of possible values for a type, or need something more specific than what itype gives us. In these cases, we can create our own shrinker, by maping, filtering and interleaveing existing integrated shrinkers.","category":"page"},{"location":"Examples/structs.html#map","page":"Generating Structs","title":"map","text":"","category":"section"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"Suppose we have a type that can only hold even numbers. If we try to give it an odd number, it will throw an error on construction:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"struct EvenNumber\n    val::Int\n    function EvenNumber(v)\n        iseven(v) || throw(ArgumentError(\"Argument '$(v)' is not an even number!\"))\n        new(convert(Int, v))\n    end\nend","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"If we try to check that this type truly can only hold even numbers, we can do it like so:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"function even_construction(x)\n    try\n        v = EvenNumber(x)\n    catch e\n        err = ArgumentError(\"Argument '$x' is not an even number!\")\n        return e == err && isodd(x)\n    end\n    return true\nend\nusing PropCheck\ncheck(even_construction, itype(Int8))","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"So far so good. But what now if we want to test some code that relies on this even number, and we don't care for testing whether the construction works in the first place? Naively, we can construct an integrated shrinker creating instances of EvenNumber like so:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"iEvenNumThrowing = map(EvenNumber, itype(Int8));","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"but this has the issue that creating objects of EvenNumber would try to create invalid instances, and throw an error:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"try\n    # it's a 50/50 chance of throwing - this ought to be enough samples\n    for _ in 1:100_000\n        generate(iEvenNumThrowing)\n    end\ncatch e\n    e\nend","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"We can work around this by maping not only our constructor, but also by crafting the input to EvenNumber in such a way as to never trigger the error:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"iEvenNum = map(itype(Int8)) do i\n    EvenNumber(div(i,2)*2)\nend;\ncheck(iEvenNum) do en\n    iseven(en.val)\nend","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"This pattern can be extended indefinitely; the return type of map can itself be maped again, as it produces another integrated shrinker.","category":"page"},{"location":"Examples/structs.html#filter","page":"Generating Structs","title":"filter","text":"","category":"section"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"While map is useful for cases where we can transform some invalid input into a valid one, filter can be used for rejecting some set of values entirely.","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"Consider this:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"using PropCheck\ni0to1 = isample(0:0.00001:1.0);\niquadr = filter(PropCheck.tuple(iconst(2), i0to1)) do tup\n    sqrt(tup[1]^2 + tup[2]^2) <= 1\nend;","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"We first define a generator for sampling numbers from 0.0:0.00001:1.0, and use that to create Tuple{Float64,Float64} consisting of coordinates in the first quadrant of the unit circle. Let's confirm that this is the case:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"check(iquadr) do coords\n    sqrt(coords[1]^2 + coords[2]^2) <= 1\nend","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"And sure enough, the trivial property holds - we filtered for it after all. What if we now want to filter for a band of values, for example an arch with outer radius 1.0 and inner radius 0.8? This rejects a large portion of (so far) legal values:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"iarch = filter(iquadr) do tup\n    sqrt(tup[1]^2 + tup[2]^2) >= 0.8 \nend;\ntry\n    for _ in 1:100_000\n        generate(iarch)\n    end\ncatch e\n    e\nend","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"Even just trying to generate such a value, with naive filtering, leads to a stackoverflow, or worse, close to infinite loops. This is because filter tries to be optimistic - when it encounters a value that doesn't match its filter criterion, it tries the shrinks of that value as well. In the case of our donut shaped filtering combination, this tries a huge number of additional examples that we know we can reject outright, because their shrinks can never be valid outputs; once the distance from the origin of a point is less than 0.8, any shrinks of those coordinates must be closer to the origin yet again, making the shrunk coordinates trivially rejectable. To communicate this to filter, we can pass a third argument trim, steering whether filter should trim shrinks of a rejected value entirely or not:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"iarch = filter(iquadr, true) do tup\n    sqrt(tup[1]^2 + tup[2]^2) >= 0.8 \nend;\ngenerate(iarch)","category":"page"},{"location":"Examples/structs.html#Bias","page":"Generating Structs","title":"Bias","text":"","category":"section"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"Even though the returned numbers lie in our desired band, they are biased because our first filtering step did not reject shrinks, but instead tried them as well. This results in clumping of values:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"(Image: Biased filtering)","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"This can be easily fixed, by just trimming the values of the first generator as well, resulting in this distribution:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"iquadrUnbias = filter(PropCheck.tuple(iconst(2), i0to1), true) do tup\n    sqrt(tup[1]^2 + tup[2]^2) <= 1\nend","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"(Image: Unbiased filtering)","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"The plots were produced with this script:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"using CairoMakie\npointsBias = [ root(generate(iquard)) for _ in 1:500_000 ]\npointsUnbias = [ root(generate(iquardUnbias)) for _ in 1:500_000 ]\nscatter(pointsBias; markersize=0.8)\nscatter(pointsUnbias; markersize=0.8)","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"This bias may not be an issue in every applicable situation, but should be considered in general. Do note that this only shows the first level of produced values; the shrinking function may introduce another layer of bias not shown here.","category":"page"},{"location":"Examples/structs.html#Considerations-when-using-filter","page":"Generating Structs","title":"Considerations when using filter","text":"","category":"section"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"Filtering comes at an additional cost - due to the nature of filter, it may reject all produced values and exhaust the generator, which ends up producing Nothing.  As such, filter may not return any values at all, introducing a type instability.","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"Further, because filter needs to attempt to generate a value before it can decide whether or not the value needs to be filtered out, you may encounter additional overhead if the set of values that could be generated is close to the set of values that are rejected. I.e., if you reject most of the values generated by a generator as in the idonut example above, it is usually better to try to construct your values such that they don't need to be filtered in the first place, instead of filtering after the fact. In the example shown above, it would have been better to generate values from isample(0.8:0.00001:1.0) in the first place. Filtering really should only be a last resort.","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"In some cases, such as when sampling a PropCheck.vector from an isample(3:8), filtering can't be avoided, because the generated Vectors need to have a length of at least 3.","category":"page"},{"location":"Examples/structs.html#interleave","page":"Generating Structs","title":"interleave","text":"","category":"section"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"We've seen so far how to generate plain values from types, create simple structs, as well as filter & map functions over integrated shrinkers. Now, let's take a look at how to create more complicated objects implicitly, with interleave.","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"Consider this struct:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"using PropCheck\n\nstruct Person\n    name::String\n    age::Int\n    height::Int\n    favorite_color::String\n    function Person(name::String, age::Int, height::Int, favorite_color::String)\n        age < 0 && throw(ArgumentError(\"`age` must be a positive `Int`!\"))\n        height < 0 && throw(ArgumentError(\"`height` must be a positive `Int`!\"))\n        new(name, age, height, favorite_color)\n    end\nend","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"How might we construct objects of this type? We know that there's at least one constructor, the three-arg Person, which ensures that we can only create Person objects that satisfy our criteria. Naively, we need at least a 4-tuple of values that we could splat into Person, like Person((\"Agnes\", 26, 178, \"Violet\")...) and we know that we could create such a tuple with type(Tuple{String,Int,Int,String}), but this has a few issues:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"We'd have to filter out or map any tuples that have an age or height less than 0 manually.\nWe have no control over the exact name and favorite_color strings.\nWe have no control over the shrinking of each field; We may want to create a generator that doesn't shrink the persons name, for example.","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"Let's first define some generators we might want to use for the individual fields, starting out with age and height:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"iage = isample(0:125); # the oldest living person at time of writing is 116; the oldest recorded was 122\niheight = isample(0:300); # 3 meters is a reasonable maximum","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"For the name, we'd like to sample from a pool of names (though depending on what we want to test, we may want to generate arbitrary unicode instead, to check that we're handling it correctly!) and we'd also like to prevent shrinking of the name. Sampling from a pool of names can be done with isample, just as with age and to prevent shrinking we can pass PropCheck.noshrink, which just returns an empty list, indicating no shrinks, as the shrinking function:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"names = [\"Agnes\", \"Bert\", \"Charlie\", \"Diana\", \"Emma\", \"Fredrick\", \"Ruby\"]\niname = isample(names, PropCheck.noshrink);","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"Similarly, we'd like to sample their favorite colours and not shrink them as well:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"colours = [\"Red\", \"Blue\", \"Green\", \"Yellow\", \"Beige\",\n           \"Ruby\", \"Amber\", \"Crystal\", \"Dark Blue\", \"Ivory\"];\nicolor = isample(colours, PropCheck.noshrink);","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"On their own, these generators simply create their usual objects:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"generate(iage)\ngenerate(iheight)\ngenerate(iname)\ngenerate(icolor)","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"with iname and icolor of course having no shrinks:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"generate(iname) |> subtrees |> isempty\ngenerate(icolor) |> subtrees |> isempty","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"We can combine these individual integrated shrinkers into one by using the interleave function, which returns an integrated shrinker that produces tuples of the passed in values:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"iargs = interleave(iname, iage, iheight, icolor);\ngenerate(iargs)","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"To now build a person from all these ingredients, all we need to do is splat that generated tuple into our constructor:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"iperson = map(splat(Person), iargs);\ngenerate(iperson)","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"which we can of course use to check some property:","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"check(iperson; ntests=10_000) do p\n    if p.name == p.favorite_color\n        p.age < 22\n    else\n        true\n    end\nend","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"Returning the only combination of names and colours that matches; Person(\"Ruby\", 22, 0, \"Ruby\"), who rightfully didn't let anyone tell her that her favorite color can't be the same as her name.","category":"page"},{"location":"Examples/structs.html","page":"Generating Structs","title":"Generating Structs","text":"Note how interleave managed to shrink both the age, as well as the height from the initial counterexample. This is the strength of interleave, compared to just naively generating the the arguments one-by-one and constructing the object manually, instead of letting PropCheck do it for you.","category":"page"}]
}
