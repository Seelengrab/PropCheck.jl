<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generating Structs · PropCheck.jl Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">PropCheck.jl Documentation</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Main Page</a></li><li><a class="tocitem" href="../intro.html">Introduction to PBT</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="basic.html">Basic Usage</a></li><li class="is-active"><a class="tocitem" href="structs.html">Generating Structs</a><ul class="internal"><li><a class="tocitem" href="#map"><span><code>map</code></span></a></li><li><a class="tocitem" href="#filter"><span><code>filter</code></span></a></li><li><a class="tocitem" href="#interleave"><span><code>interleave</code></span></a></li></ul></li><li><a class="tocitem" href="containers.html">Generating Containers</a></li><li><a class="tocitem" href="properties.html">Composing Generators</a></li><li><a class="tocitem" href="chaining.html">Generator Chaining</a></li></ul></li><li><a class="tocitem" href="../shrinktrees.html">Shrinking with <code>Tree</code>s</a></li><li><a class="tocitem" href="../faq.html">FAQ</a></li><li><a class="tocitem" href="../interfaces.html">Interfaces</a></li><li><a class="tocitem" href="../api.html">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href="structs.html">Generating Structs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="structs.html">Generating Structs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Seelengrab/PropCheck.jl/blob/main/docs/src/Examples/structs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Generating-Structs"><a class="docs-heading-anchor" href="#Generating-Structs">Generating Structs</a><a id="Generating-Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-Structs" title="Permalink"></a></h1><p>While we can get pretty far with generating basic types like <code>Int</code> or <code>String</code>, sometimes we need to make additional guarantees or don&#39;t need to generate the full spectrum of possible values for a type, or need something more specific than what <code>itype</code> gives us. In these cases, we can create our own shrinker, by <code>map</code>ing, <code>filter</code>ing and <code>interleave</code>ing existing integrated shrinkers.</p><h2 id="map"><a class="docs-heading-anchor" href="#map"><code>map</code></a><a id="map-1"></a><a class="docs-heading-anchor-permalink" href="#map" title="Permalink"></a></h2><p>Suppose we have a type that can only hold even numbers. If we try to give it an odd number, it will throw an error on construction:</p><pre><code class="language-julia hljs">struct EvenNumber
    val::Int
    function EvenNumber(v)
        iseven(v) || throw(ArgumentError(&quot;Argument &#39;$(v)&#39; is not an even number!&quot;))
        new(convert(Int, v))
    end
end</code></pre><p>If we try to check that this type truly can only hold even numbers, we can do it like so:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function even_construction(x)
           try
               v = EvenNumber(x)
           catch e
               err = ArgumentError(&quot;Argument &#39;$x&#39; is not an even number!&quot;)
               return e == err &amp;&amp; isodd(x)
           end
           return true
       end</code><code class="nohighlight hljs ansi" style="display:block;">even_construction (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using PropCheck</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; check(even_construction, itype(Int8))</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>So far so good. But what now if we want to test some code that relies on this even number, and we don&#39;t care for testing whether the construction works in the first place? Naively, we can construct an integrated shrinker creating instances of <code>EvenNumber</code> like so:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; iEvenNumThrowing = map(EvenNumber, itype(Int8));</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>but this has the issue that creating objects of <code>EvenNumber</code> would try to create invalid instances, and throw an error:</p><pre><code class="language-julia hljs">try
    # it&#39;s a 50/50 chance of throwing - this ought to be enough samples
    for _ in 1:100_000
        generate(iEvenNumThrowing)
    end
catch e
    e
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ArgumentError(&quot;Argument &#39;-79&#39; is not an even number!&quot;)</code></pre><p>We can work around this by <code>map</code>ing not only our constructor, but also by crafting the input to <code>EvenNumber</code> in such a way as to never trigger the error:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; iEvenNum = map(itype(Int8)) do i
           EvenNumber(div(i,2)*2)
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; check(iEvenNum) do en
           iseven(en.val)
       end</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>This pattern can be extended indefinitely; the return type of <code>map</code> can itself be <code>map</code>ed again, as it produces another integrated shrinker.</p><h2 id="filter"><a class="docs-heading-anchor" href="#filter"><code>filter</code></a><a id="filter-1"></a><a class="docs-heading-anchor-permalink" href="#filter" title="Permalink"></a></h2><p>While <code>map</code> is useful for cases where we can transform some invalid input into a valid one, <code>filter</code> can be used for rejecting some set of values entirely.</p><p>Consider this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using PropCheck</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; i0to1 = isample(0:0.00001:1.0);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; iquadr = filter(PropCheck.tuple(iconst(2), i0to1)) do tup
           sqrt(tup[1]^2 + tup[2]^2) &lt;= 1
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>We first define a generator for sampling numbers from <code>0.0:0.00001:1.0</code>, and use that to create <code>Tuple{Float64,Float64}</code> consisting of coordinates in the first quadrant of the unit circle. Let&#39;s confirm that this is the case:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; check(iquadr) do coords
           sqrt(coords[1]^2 + coords[2]^2) &lt;= 1
       end</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>And sure enough, the trivial property holds - we filtered for it after all. What if we now want to filter for a band of values, for example an arch with outer radius <code>1.0</code> and inner radius <code>0.8</code>? This rejects a large portion of (so far) legal values:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; iarch = filter(iquadr) do tup
           sqrt(tup[1]^2 + tup[2]^2) &gt;= 0.8
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; try
           for _ in 1:100_000
               generate(iarch)
           end
       catch e
           e
       end</code><code class="nohighlight hljs ansi" style="display:block;">StackOverflowError()</code></pre><p>Even just trying to generate such a value, with naive filtering, leads to a stackoverflow, or worse, close to infinite loops. This is because <code>filter</code> tries to be optimistic - when it encounters a value that doesn&#39;t match its filter criterion, it tries the shrinks of that value as well. In the case of our donut shaped filtering combination, this tries a huge number of additional examples that we know we can reject outright, because their shrinks can never be valid outputs; once the distance from the origin of a point is less than <code>0.8</code>, any shrinks of those coordinates must be closer to the origin yet again, making the shrunk coordinates trivially rejectable. To communicate this to <code>filter</code>, we can pass a third argument <code>trim</code>, steering whether <code>filter</code> should trim shrinks of a rejected value entirely or not:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; iarch = filter(iquadr, true) do tup
           sqrt(tup[1]^2 + tup[2]^2) &gt;= 0.8
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; generate(iarch)</code><code class="nohighlight hljs ansi" style="display:block;">Tree((0.4729826308824606, 0.87261))</code></pre><h3 id="Bias"><a class="docs-heading-anchor" href="#Bias">Bias</a><a id="Bias-1"></a><a class="docs-heading-anchor-permalink" href="#Bias" title="Permalink"></a></h3><p>Even though the returned numbers lie in our desired band, they are <em>biased</em> because our first filtering step did not reject shrinks, but instead tried them as well. This results in clumping of values:</p><p><img src="../assets/filter_bias.png" alt="Biased filtering"/></p><p>This can be easily fixed, by just trimming the values of the first generator as well, resulting in this distribution:</p><pre><code class="language-julia hljs">iquadrUnbias = filter(PropCheck.tuple(iconst(2), i0to1), true) do tup
    sqrt(tup[1]^2 + tup[2]^2) &lt;= 1
end</code></pre><p><img src="../assets/filter_unbiased.png" alt="Unbiased filtering"/></p><p>The plots were produced with this script:</p><pre><code class="language-julia hljs">using CairoMakie
pointsBias = [ root(generate(iquard)) for _ in 1:500_000 ]
pointsUnbias = [ root(generate(iquardUnbias)) for _ in 1:500_000 ]
scatter(pointsBias; markersize=0.8)
scatter(pointsUnbias; markersize=0.8)</code></pre><p>This bias may not be an issue in every applicable situation, but should be considered in general. Do note that this only shows the first level of produced values; the shrinking function may introduce another layer of bias not shown here.</p><h3 id="Considerations-when-using-filter"><a class="docs-heading-anchor" href="#Considerations-when-using-filter">Considerations when using <code>filter</code></a><a id="Considerations-when-using-filter-1"></a><a class="docs-heading-anchor-permalink" href="#Considerations-when-using-filter" title="Permalink"></a></h3><p>Filtering comes at an additional cost - due to the nature of <code>filter</code>, it may reject all produced values and exhaust the generator, which ends up producing <code>Nothing</code>.  As such, <code>filter</code> may not return any values at all, introducing a type instability.</p><p>Further, because <code>filter</code> needs to attempt to generate a value before it can decide whether or not the value needs to be filtered out, you may encounter additional overhead if the set of values that could be generated is close to the set of values that are rejected. I.e., if you reject most of the values generated by a generator as in the <code>idonut</code> example above, it is usually better to try to construct your values such that they don&#39;t need to be filtered in the first place, instead of filtering after the fact. In the example shown above, it would have been better to generate values from <code>isample(0.8:0.00001:1.0)</code> in the first place. Filtering really should only be a last resort.</p><p>In some cases, such as when sampling a <code>PropCheck.vector</code> from an <code>isample(3:8)</code>, filtering can&#39;t be avoided, because the generated <code>Vector</code>s need to have a length of at least <code>3</code>.</p><h2 id="interleave"><a class="docs-heading-anchor" href="#interleave"><code>interleave</code></a><a id="interleave-1"></a><a class="docs-heading-anchor-permalink" href="#interleave" title="Permalink"></a></h2><p>We&#39;ve seen so far how to generate plain values from types, create simple structs, as well as filter &amp; map functions over integrated shrinkers. Now, let&#39;s take a look at how to create more complicated objects implicitly, with <code>interleave</code>.</p><p>Consider this struct:</p><pre><code class="language-julia hljs">using PropCheck

struct Person
    name::String
    age::Int
    height::Int
    favorite_color::String
    function Person(name::String, age::Int, height::Int, favorite_color::String)
        age &lt; 0 &amp;&amp; throw(ArgumentError(&quot;`age` must be a positive `Int`!&quot;))
        height &lt; 0 &amp;&amp; throw(ArgumentError(&quot;`height` must be a positive `Int`!&quot;))
        new(name, age, height, favorite_color)
    end
end</code></pre><p>How might we construct objects of this type? We know that there&#39;s at least one constructor, the three-arg <code>Person</code>, which ensures that we can only create <code>Person</code> objects that satisfy our criteria. Naively, we need at least a 4-tuple of values that we could splat into <code>Person</code>, like <code>Person((&quot;Agnes&quot;, 26, 178, &quot;Violet&quot;)...)</code> and we know that we could create such a tuple with <code>type(Tuple{String,Int,Int,String})</code>, but this has a few issues:</p><ul><li>We&#39;d have to filter out or <code>map</code> any tuples that have an age or height less than <code>0</code> manually.</li><li>We have no control over the exact <code>name</code> and <code>favorite_color</code> strings.</li><li>We have no control over the shrinking of each field; We may want to create a generator that doesn&#39;t shrink the persons name, for example.</li></ul><p>Let&#39;s first define some generators we might want to use for the individual fields, starting out with <code>age</code> and <code>height</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; iage = isample(0:125); # the oldest living person at time of writing is 116; the oldest recorded was 122</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; iheight = isample(0:300); # 3 meters is a reasonable maximum</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>For the name, we&#39;d like to sample from a pool of names (though depending on what we want to test, we may want to generate arbitrary unicode instead, to check that we&#39;re handling it correctly!) and we&#39;d also like to prevent shrinking of the name. Sampling from a pool of names can be done with <code>isample</code>, just as with <code>age</code> and to prevent shrinking we can pass <code>PropCheck.noshrink</code>, which just returns an empty list, indicating no shrinks, as the shrinking function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; names = [&quot;Agnes&quot;, &quot;Bert&quot;, &quot;Charlie&quot;, &quot;Diana&quot;, &quot;Emma&quot;, &quot;Fredrick&quot;, &quot;Ruby&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">7-element Vector{String}:
 &quot;Agnes&quot;
 &quot;Bert&quot;
 &quot;Charlie&quot;
 &quot;Diana&quot;
 &quot;Emma&quot;
 &quot;Fredrick&quot;
 &quot;Ruby&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; iname = isample(names, PropCheck.noshrink);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Similarly, we&#39;d like to sample their favorite colours and not shrink them as well:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; colours = [&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Beige&quot;,
                  &quot;Ruby&quot;, &quot;Amber&quot;, &quot;Crystal&quot;, &quot;Dark Blue&quot;, &quot;Ivory&quot;];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; icolor = isample(colours, PropCheck.noshrink);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>On their own, these generators simply create their usual objects:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; generate(iage)</code><code class="nohighlight hljs ansi" style="display:block;">Tree(18)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; generate(iheight)</code><code class="nohighlight hljs ansi" style="display:block;">Tree(60)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; generate(iname)</code><code class="nohighlight hljs ansi" style="display:block;">Tree(Fredrick)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; generate(icolor)</code><code class="nohighlight hljs ansi" style="display:block;">Tree(Beige)</code></pre><p>with <code>iname</code> and <code>icolor</code> of course having no shrinks:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; generate(iname) |&gt; subtrees |&gt; isempty</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; generate(icolor) |&gt; subtrees |&gt; isempty</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>We can combine these individual integrated shrinkers into one by using the <code>interleave</code> function, which returns an integrated shrinker that produces tuples of the passed in values:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; iargs = interleave(iname, iage, iheight, icolor);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; generate(iargs)</code><code class="nohighlight hljs ansi" style="display:block;">Tree((&quot;Diana&quot;, 63, 234, &quot;Crystal&quot;))</code></pre><p>To now build a person from all these ingredients, all we need to do is splat that generated tuple into our constructor:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; iperson = map(splat(Person), iargs);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; generate(iperson)</code><code class="nohighlight hljs ansi" style="display:block;">Tree(Main.Person(&quot;Ruby&quot;, 54, 241, &quot;Beige&quot;))</code></pre><p>which we can of course use to check some property:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; check(iperson; ntests=10_000) do p
           if p.name == p.favorite_color
               p.age &lt; 22
           else
               true
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">┌ Info: Found counterexample for &#39;#1&#39;, beginning shrinking...
└   Counterexample = Main.Person(&quot;Ruby&quot;, 65, 21, &quot;Ruby&quot;)
[ Info: 10 counterexamples found for #1
Main.Person(&quot;Ruby&quot;, 22, 0, &quot;Ruby&quot;)</code></pre><p>Returning the only combination of <code>names</code> and <code>colours</code> that matches; <code>Person(&quot;Ruby&quot;, 22, 0, &quot;Ruby&quot;)</code>, who rightfully didn&#39;t let anyone tell her that her favorite color can&#39;t be the same as her name.</p><p>Note how <code>interleave</code> managed to shrink both the age, as well as the height from the initial counterexample. This is the strength of <code>interleave</code>, compared to just naively generating the the arguments one-by-one and constructing the object manually, instead of letting PropCheck do it for you.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="basic.html">« Basic Usage</a><a class="docs-footer-nextpage" href="containers.html">Generating Containers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 12 August 2023 15:50">Saturday 12 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
