<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to PBT · PropCheck.jl Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">PropCheck.jl Documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Main Page</a></li><li class="is-active"><a class="tocitem" href="intro.html">Introduction to PBT</a><ul class="internal"><li><a class="tocitem" href="#What-is-Property-Based-Testing?"><span>What is Property Based Testing?</span></a></li><li><a class="tocitem" href="#Julia-specific-nuances"><span>Julia specific nuances</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="Examples/basic.html">Basic Usage</a></li><li><a class="tocitem" href="Examples/structs.html">Generating Structs</a></li><li><a class="tocitem" href="Examples/containers.html">Generating Containers</a></li><li><a class="tocitem" href="Examples/properties.html">Composing Generators</a></li></ul></li><li><a class="tocitem" href="shrinktrees.html">Shrinking with <code>Tree</code>s</a></li><li><a class="tocitem" href="interfaces.html">Interfaces</a></li><li><a class="tocitem" href="api.html">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="intro.html">Introduction to PBT</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="intro.html">Introduction to PBT</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Seelengrab/PropCheck.jl/blob/main/docs/src/intro.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>What follows is a short introduction to what Property Based Testing (PBT) is from my POV. This may not be exhaustive - if you want a more formal or deeper dive into this topic, I can greatly recommend <a href="https://hypothesis.works/articles/what-is-property-based-testing/">this</a> article by one of the authors of Hypothesis, a property based testing framework. For more formal methods, check out the <a href="https://hillelwayne.com/post/">blog of Hillel Wayne</a>.</p><p>If you&#39;re fine with the (short) introduction I&#39;m giving, but want some sort of motivation about WHY you should care, here&#39;s a <a href="https://hillelwayne.com/how-do-we-trust-science-code/">quote from him</a>, itself referencing other people:</p><blockquote><p>In 2010 Carmen Reinhart and Kenneth Rogoff published <a href="http://scholar.harvard.edu/files/rogoff/files/growth_in_time_debt_aer.pdf">Growth in a Time of Debt</a>. It’s arguably one of the most influential economics papers of the decade, convincing the IMF to push austerity measures in the European debt crisis. It was a very, very big deal.</p><p>In 2013 they shared their code with another team, <a href="http://www.nytimes.com/2013/04/19/opinion/krugman-the-excel-depression.html">who quickly found a bug</a>. Once corrected, the results disappeared.</p><p>Greece took on austerity because of a software bug. That’s pretty fucked up.</p></blockquote><p>Now that I have your attention, let&#39;s get started:</p><h2 id="What-is-Property-Based-Testing?"><a class="docs-heading-anchor" href="#What-is-Property-Based-Testing?">What is Property Based Testing?</a><a id="What-is-Property-Based-Testing?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-Property-Based-Testing?" title="Permalink"></a></h2><p>Property Based Testing is the idea of checking the correctness of a function, algorithm or calculation against a number of desired properties that function should observe. Consider this function:</p><pre><code class="language-julia hljs">function foo(a::Int, b::Int)
    a &lt; 5 &amp;&amp; return false
    b &lt; 5 &amp;&amp; return false
    return true
end</code></pre><p>From reading the source code as a user, we can see that</p><ol><li><code>a</code> and <code>b</code> must be of type <code>Int</code></li><li>if either <code>a</code> or <code>b</code> is smaller than <code>5</code>, the function returns <code>false</code>, otherwise it returns <code>true</code>.</li></ol><p>So the property that should hold for this function is that if we supply two <code>Int</code> arguments, the function will always tell us whether they are both at least <code>5</code>. We might define this property for testing purposes like so:</p><pre><code class="language-julia hljs">function foo_prop()
    a = rand(Int)
    b = rand(Int)
    if a &lt; 5 || b &lt; 5
        return foo(a,b) == false
    else
        return foo(a,b) == true
    end
end</code></pre><p>Every time we run <code>foo_prop</code>, we generate a random input for <code>foo</code> and check whether its output behaves as expected. Written like this, it has a few major drawbacks:</p><ol><li>Being somewhat certain that we cover the function completely quickly becomes infeasible</li><li>We have no control over the numbers being generated</li><li>We can&#39;t reuse the way we generate these numbers; expanding a testsuite like this leads to a lot of boilerplate and repetition</li></ol><p>On its own, just <code>foo_prop</code> is already property based testing - we take some expected input and check it against the expected output/behavior. However, on 64-bit systems, <code>Int</code> has a value in the interval <code>[-9223372036854775808, 9223372036854775807]</code>, which is one of <span>$2^{64}$</span> different values. Considering that our function takes two of those, our input space has <span>$2^{2 \times 64}$</span> distinct pairs of elements! Looping through all of them would take much too long. Worse, we may then need to record the result for each of them to prove later that we actually checked it. With more complex data types, this only grows worse as more different types and combinations of them are involved.</p><p>This is where a related approach called fuzzing comes in - instead of checking ALL values and giving a 100% guarantee that it works as expected, we only check a sampled subset of all possible values and therefore only receive a probabilistic result. However, this comes with the distinct advantage of being <em>much, much faster</em> than checking all possible values. We trade accuracy for performance (much like we do with floating point values). If our sampling is good enough &amp; representative of the actual data we&#39;d usually expect, this can be a very good indicator for correctness on our input. The difficulty comes from the second point above - controlling the values we put in to a satisfying degree, as well as, once a failure is found, reducing it to something we humans can more easily use to pinpoint the uncovered bug, through a process called &quot;shrinking&quot;. You can find the introductory explanations for how this works in the context of <code>PropCheck.jl</code> in the <a href="Examples/basic.html#Basic-Usage">Basic Usage</a> section of the examples.</p><h2 id="Julia-specific-nuances"><a class="docs-heading-anchor" href="#Julia-specific-nuances">Julia specific nuances</a><a id="Julia-specific-nuances-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-specific-nuances" title="Permalink"></a></h2><p>Consider this (seemingly!) very trivial function:</p><pre><code class="language-julia hljs">function add(a,b)
    a + b
end</code></pre><p>Obviously, this function does nothing more than forward its arguments to <code>+</code>. From reading the source code above, we&#39;d expect this to always behave the same as addition - and we&#39;d probably be right! In julia though, a few subtleties come into play:</p><ul><li>We don&#39;t know the type of the input arguments</li><li>We don&#39;t know how many different values each argument can take on</li><li>We don&#39;t know whether <code>+</code> is implemented on whatever we get in the first place<ul><li>If it is, we don&#39;t know its implementation and we don&#39;t know whether it&#39;s correct/as we expect</li></ul></li></ul><p>So in reality, purely from reading the source code, we know nothing more about <code>add</code> other than &quot;passes its argument to <code>+</code>&quot;. This sort of genericity is both a blessing and a curse, in that it allows anyone that has <code>+</code> defined on two types to call our function, while also making it devilishly difficult for us as developers to anticipate all possible behaviors that can occur.</p><p>With property based testing, we should in theory be able to define a set of properties we&#39;d like to hold on our code, for any object that can be passed into our <code>add</code> function. Users of our code who define a new type should be able to take those properties and check the behavior of their type &amp; implementation in our function against the expected properties and find out (at least probabilistically) whether they&#39;ve implemented the required functions correctly.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Main Page</a><a class="docs-footer-nextpage" href="Examples/basic.html">Basic Usage »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 7 July 2023 13:42">Friday 7 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
